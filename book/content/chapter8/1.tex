
大约30年前，在那个狂野的90年代末期，本文作者曾耗费大量时间优化代码——这些代码需要在消耗最少资源的同时，以最快速度运行，在屏幕上展现令人惊叹的旋转图形(还涉及滚动等其他与本文无关的计算)。

这些被称为"演示程序"(demos/intros)的应用，依托扎实的数学基础和自主开发的图形引擎，呈现了惊艳的视觉效果。在那个没有DirectX替你处理底层细节的年代，所有工作都必须手工完成：像素色彩计算、调色板设置、CRT显示器垂直回扫、前后缓冲区切换等，全都用90年代的C++和关键时序部分的汇编语言亲手编写。

其中最基本的一个功能就是在屏幕上绘制像素，其最简实现形式如下：

\begin{cpp}
void putpixel(int x, int y, unsigned char color) {
  unsigned char far* vid_mem = (unsigned char far*)0xA0000000L;
  vid_mem[(y * 320) + x] = color;
}
\end{cpp}

这里我就不赘述诸如30年前的段地址/偏移量内存机制这类底层细节了。

让我们假设以下背景：

\begin{itemize}
\item 
你正在使用DOS系统(1994年，在东欧偏远地区，几乎所有PC用户都使用DOS——向那0.1\%的早期Linux用户致敬)

\item 
你使用的是特殊的0x13图形模式(当时几乎所有游戏都采用这个模式，因为它能以神秘的320×200分辨率显示256色，这个规格的由来恐怕只有40年前的IBM工程师才知道)
\end{itemize}

在这种情况下，如果你往0xA000段地址的特定偏移量写入一个字节，显卡就会按照给定公式计算出的坐标点亮对应像素。

经过多次代码迭代后，这位开发者发现这个例程并不够优化，还有提升空间。

请耐心听我说：当时平价编译器(就是你在本书第2章提到的从软盘拷贝的那种)生成的代码如下(截图所示)：

\myGraphic{0.9}{content/chapter8/images/1.png}{图 8.1 --- 30 年前大家最喜欢的 Turbo 调试器}

考虑到这段代码的年代，它看起来确实相当"狂野"，但请稍安勿躁——所有关于它为何存在的谜团都将揭晓。记得我们刚才在讨论编译器生成的代码远非最优吗？

让我们花点时间审视这段代码。特别是从如今日渐稀少的汇编语言专家的视角来看，他们可能会立刻意识到：编译器的表现其实比我们预期的要好得多。

以下是编译器为putpixel例程生成的汇编代码：

\begin{shell}
putpixel proc near
  push bp ; Save the base pointer on the stack
  mov bp, sp ; Set the BP to the current stack pointer
  sub sp, 4 ; Reserve 4 bytes for local variables
  mov word ptr [bp-2], 40960 ; Store 0xA000 at [bp-2]
  mov word ptr [bp-4], 0 ; Store 0 at [bp-4]
  mov ax, word ptr [bp+6] ; Load the y-coordinate into AX
  mov dx, 320 ; Load the screen width into DX
  imul dx ; Multiply AX (y-coord) by DX (screen width)
  mov bx, word ptr [bp+4] ; Load the x-coordinate into BX
  add bx, ax ; Add y*screen width (AX) to BX (x-coord)
  mov es, word ptr [bp-2] ; Load 0xA000 into ES
  add bx, word ptr [bp-4] ; Final pixel address in BX
  mov al, byte ptr [bp+8] ; Load the color value into AL
  mov byte ptr es:[bx], al ; Light the pixel!
  mov sp, bp ; Restore the stack pointer
  pop bp ; Restore the base pointer
  ret ; Return from the procedure
\end{shell}

对于不熟悉这种表示法的读者，方括号[]表示取其中地址对应的数据，因此参数是这样传递的：

\begin{itemize}
\item 
像素的x坐标(来自[bp+4])

\item 
像素的y坐标(来自[bp+6]) 

\item 
要设置的颜色值(来自[bp+8])
\end{itemize}

这段代码确实存在大量不必要的内存存取操作，其实这些数据完全可以保存在寄存器中。此外还有许多可以跳过的内存区域访问。当时的编译器生成的代码虽然便于调试，但本可以写得更加简洁。现代编译器在Debug模式下生成的代码性能与之相似，但一旦切换到优化后的Release模式，它们就会展现出惊人的优化能力。

现代CPU是高度复杂的"怪兽"——在保护模式下运行时，它们采用乱序执行、指令流水线等技术，使得如今的底层性能分析变得相当困难...但老式机器要简单得多！或者在现代电脑上运行DOS也能获得相似的体验。

考虑到保护模式早在80286处理器时代就已引入，但DOS根本无法处理(至今仍然不能)，所以它坚持使用最拿手的实模式。在实模式下，处理器只是逐条执行指令，甚至还有指令周期表详细说明每条指令所需的时钟周期\footnote{\url{https://zs3.me/intel.php}}。

经过大量时间查阅这些周期表后，我们得出了一个结论：在当时处理器上，一次乘法操作可能比两次位移加一次加法更耗时(全球数千名开发者查阅周期表后也得出了相同结论，但我们当时觉得自己发现这个特性简直像是本地英雄)。

考虑到320是个很"友好"的数字(它是256和64的和)，经过多轮优化后，我们为这个例程提出了以下稍加优化的版本：

\begin{cpp}
void putpixel(int x, int y, unsigned char c) {
asm {
    mov ax, 0xA000 // Load 0xA000 (VGA mode 13h) into AX
    mov es, ax // Set ES to the video segment (0xA000)
    mov dx, y // Load the y-coordinate into DX
    mov di, x // Load the x-coordinate into DI
    mov bx, y // Copy the y-coordinate into BX
    shl dx, 8 // Multiply DX by 256 (left shift by 8 bits)
    shl bx, 6 // Multiply BX by 64 (left shift by 6 bits)
    add dx, bx // Add those, effectively multiplying y by 320
    add di, dx // Add the calculated y to DI (pixel offset)
    mov al, c // Load the color value into AL
    stosb // Light the pixel
  } 
}
\end{cpp}

虽然这并非能达到的最优实现，但完全满足我们的特定需求。

该版本大幅减少了直接内存访问(即便在当年这也被认为是低速操作)，并将耗时的320乘法(imul)替换为256(左移8位：shl dx,8)与64(左移6位)的位移操作再求和，总时钟周期仍少于原始乘法运算。

由此催生了一个根深蒂固的观念：若追求极致性能，就必须亲手编写底层代码。

但让我们做个有趣的思维实验——跨越30年时光，跳过数代编译器演进。若将原始C++代码输入现代编译器(本文使用Clang 18.1，GCC也会产生类似结果，仅寄存器组合不同)，将得到如下输出：

\begin{shell}
putpixel(int, int, unsigned char):
  movzx eax, byte ptr [esp + 12]
  mov ecx, dword ptr [esp + 4]
  mov edx, dword ptr [esp + 8]
  lea edx, [edx + 4*edx]
  shl edx, 6
  mov byte ptr [edx + ecx + 40960], al
\end{shell}

这段代码比我们三十年前精心设计、针对当时处理器优化的版本精简得多。处理器在这三十年间经历了巨大进化——新增了诸多先进特性与指令集(本章稍后将详述新指令)，而编译器优化例程对320这个"友好数字"的乘法处理方式尤其令人叹服。

从Turbo C++、Watcom C++等早期版本起步，C++编译器已发展为极其复杂的系统。它们不再只是简单地将人类可读代码转译为机器码，而是能通过函数内联、循环展开、常量折叠、死代码消除等高级优化技术，以及跨模块/程序的全局优化策略，显著提升性能与内存使用效率。GCC、Clang和MSVC都充分利用现代硬件特性(如向量化与并行指令)，针对特定处理器生成高效机器码(下节实例将生动展示这些优化效果)。

不过，在进入正题前，请允许我再分享一个三十年前的案例。本章副标题"这已经是性能的底线"本意指不应采用更低级的编码方式——但此刻我们要自豪地自我反驳：在某些情况下，你确实需要突破汇编层面向下探索。

熟悉图形编程的读者应该了解双缓冲技术：后备缓冲区(与屏幕等大的离屏内存区域)先完成所有图形渲染，再整块拷贝至屏幕显示。历史上加拿大开发者Tom Duff发明的"Duff装置"(一种循环展开技术)完美解决了这个问题。不过我们要展示的是当年自诩"高度优化"的后备缓冲区拷贝代码：

\begin{cpp}
void flip(unsigned int source, unsigned int dest) {
asm {
    push ds // Save the current value of the DS register
    mov ax, dest // Load the destination address into AX
    mov es, ax // Copy the value from AX into the ES
    mov ax, source // Load the source address into AX
    mov ds, ax // Copy the value in AX into the DS
    xor si, si // Zero out the SI (source index) register
    xor di, di // Zero out the DI (destination index)
    mov cx, 64000 // Load 64000 into the CX register
    // (this is the number of bytes to copy)
    rep movsb // Run the`movsb` instruction 64000
    // times (movsb copies bytes from DS:SI to ES:DI)
    pop ds // Restore the original value of the DS
  } 
}
\end{cpp}

这段代码的精髓在于rep movsb指令——它会按照CX寄存器指定的次数(64,000次)重复执行字节拷贝(movsb)。这个魔法数字的由来我们都清楚：64,000 = 320×200(屏幕分辨率)。

在当时的硬件环境下，这段代码堪称完美。但若使用至少80386这样的高端处理器(相比纯16位的80286，这是英特尔首款32位x86处理器)，我们还能进一步优化：不再拷贝64,000字节，而是改用rep movsd指令处理16,000个双字(32位)。因为1字节=8位，2字节=1字(16位)，2字=1双字(32位)——这正是新处理器原生支持的操作位宽。新引入的movsd指令单次就能拷贝4字节，理论上比旧代码快4倍。

但本书开头提到的Turbo C++ Lite编译器有个致命缺陷：它只能为80286及以下处理器生成代码，导致我们被迫使用16位寄存器和低效的寄存器操作。于是C++代码中出现了最底层的hack——我们直接在代码里以十六进制形式硬编码rep movsd指令的机器码：

\begin{shell}
xor di,di
mov cx,16000
db 0xF3,0x66,0xA5 //rep movsd
pop ds
\end{shell}

还有什么比在生产代码里看到这种操作更"简单粗暴"又令人泪目的呢？虽然我们的编译器还停留在石器时代(就像你现在读的这半章内容一样)，无法为80386生成代码，但我们依然能写出在新型处理器上最优运行的代码——不过请千万不要真的这么做。

\mySubsubsection{8.1.1}{关于往事的注记}

如今，你或许会问：在2024年这个AI驱动开发工具大行其道、低代码/无代码平台蓬勃兴起、各种语法翻新但功能雷同的JavaScript模块层出不穷的时代，我们为何还要讨论汇编语言？

尽管这些是当今IT界最喧嚣的趋势，但汇编语言仍未过时。它或许不像万众追捧的Rust语言那样风光(如果计划顺利，Alex将在后续章节探讨Rust)，但在某些关键领域，汇编仍是不可替代的刚需。以下是仍需汇编技术的核心场景：

\begin{itemize}
\item 
嵌入式系统:微控制器和物联网设备常需汇编实现高效底层编程——这些微型设备的算力捉襟见肘，每个比特都弥足珍贵。

\item 
操作系统开发:引导程序与内核关键组件依赖汇编进行硬件初始化与管理。要实现这类开发，要么供职于大企业，要么自建项目(Linux生态已基本覆盖该领域)。

\item 
高性能计算:科学计算与定制硬件(如FPGA)中，汇编用于优化性能关键代码。但前提是找到愿意为此付费的雇主。

\item 
安全与逆向工程:二进制分析与漏洞利用往往需要汇编知识。遗憾的是，这既是汇编领域最赚钱的方向，也是最现实的入行途径。

\item 
固件开发:BIOS/UEFI和底层设备驱动程序普遍使用汇编实现硬件交互。该领域同样主要由大企业主导，不过也有coreboot/libreboot等开源项目可供探索。

\item 
遗留系统维护:复古计算与老旧系统维护常需汇编技能，堪称痛苦与乐趣并存的独特体验。

\item 
专用硬件:数字信号处理器和定制CPU架构可能需要汇编实现专用高效处理。
\end{itemize}

请别急于否定汇编语言——只要计算机存在,它就永不褪色。对特定领域感兴趣者自会珍视其价值,其他人尽可继续使用标准C++。

