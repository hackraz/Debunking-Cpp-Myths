
本章将展开一番探索，剖析那些关于"C++是否真正向后兼容C"的陈词滥调——这些老生常谈的观点既无趣又烦人。几十年来，我们的导师、教师和培训师不断向我们灌输：C++基本上向后兼容C。这意味着大部分C代码只需稍作修改就能在C++中编译运行，毕竟两者共享相似的语法和标准库。

\begin{shell}
<banalities reason="these were discussed somewhere else">
\end{shell}

C与C++的亲密关系，就像功能失调家庭里的两兄弟——血脉相连却又矛盾重重，在兼容性问题上始终爱恨交织。但随着时间的推移，这两门语言已渐行渐远。根据核心规范，C语言更为宽松：它的类型规则更灵活（尤其在指针处理上），允许隐式指针转换等特性，而这些在C++中都是被明令禁止的。例如在C语言中，void*可以不经强制转换直接赋值给其他指针类型，而C++则会要求显式类型转换以维护类型安全。

这种差异同样体现在枚举类型上：C++（尤其是新版本）将枚举视为独立类型，而C语言则简单粗暴地将其当作int处理。分歧还蔓延到变量初始化、类型限定符等众多领域——甚至连内存分配函数（*alloc()）在两者中的表现都大相径庭。以malloc/calloc等函数为例：在C语言中它们就像早餐咖啡般平凡无奇，可一旦出现在C++代码里，瞬间就变成了打开地狱之门的咒语。代码评审时尤其如此：那些C++原教旨主义者会惊恐地抓着键盘，声嘶力竭地告诫你"既然有new/delete为什么还要用C函数"，甚至质问"都2024年了为什么还要手动分配内存？我们有智能指针！"。就算你非要使用，他们也至少会哀求你别用C风格强制转换——毕竟C++标准早在十多年前就提供了完善的转型操作符。

正如前文所述（当然远不止这些），年轻的C++追求更严格的类型规则和更安全的编程实践，而C语言老祖宗则保持着实用主义的灵活性——尽管要承担更大风险。

最让C++信徒毛骨悚然的是，这两门语言经常被迫同处一室：特别是当C++项目需要调用C语言库时，开发者就不得不面对双语言兼容的噩梦。啊，这该死的软件开发炼狱。

为了解决上述问题，开发者常常不得不借助extern "C"声明——这个神奇的咒语既能阻止C++的名称修饰（name mangling），又能让不同方言编写的库函数顺畅链接。究其根源，尽管C与C++血脉相连，但两者编译器生成的目标文件处理方式却大相径庭（没错，说的就是你，名称修饰！）。

更有趣的是，C99标准中那些独具特色的关键字——比如\_Alignas、\_Alignof、\_Atomic、\_Bool、\_Complex、\_Generic、\_Imaginary、\_Noreturn和\_Static\_assert——在标准C++中集体缺席（尽管部分功能可能有C++等效实现或编译器扩展）。而命运最讽刺的是，为了让C语言向C++靠拢，这些关键字从C23标准开始竟被陆续淘汰。

\begin{shell}
</banalities>
\end{shell}

然而，C语言诞生之时，根本不会想到未来会出现一门叫C++的编程语言。正因如此，下面这段C代码完全合法，但却会让所有遵纪守法的C++编译器（以及纯粹的C++开发者）当场窒息：

\begin{cpp}
int template(int this) {
  int class = 0, using = 1, delete;
  if (this == 0) return class;
  if (this == 1) return using;
  for (int friend = 2; friend <= this; friend++) {
    delete = class + using;
    class = using;
    using = delete;
  }
  return delete;
}
\end{cpp}

这段看似从C语言深渊爬出的噩梦代码，实则完全合法——更惊人的是，它居然能计算斐波那契数列。不过亲爱的读者，我们不会对你太过残忍（虽然考虑到你读到这里已经承受了本书各种"传奇"代码片段的折磨，这段代码恐怕已难让你震惊了……别担心，这是倒数第二章，苦难即将结束……不过在此之前：还记得第九章我们把main定义为return、把return定义为main的把戏吗？），现在让我们展示另一个未被C++继承的C语言神奇特性。

不，我们要讨论的并非变长数组——尽管光是\verb|void funny_fun(int n, int array[][*])|这种诡异语法就值得单独写篇论文（该语法演示了如何在函数原型声明中传递二维变长数组）。过去十年间，早有权威专家对变长数组进行了深入探讨\footnote{\url{https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3810.pdf}}，其专业程度\footnote{\url{https://nullprogram.com/blog/2019/10/27/}}远非笔者所能企及。

但即便经过这些讨论，变长数组（VLAs）仍未能进入C++标准——这背后必然存在合理考量（不仅仅是潜在的栈空间问题，或是假设理论上的无限栈可能引发的类型混乱，更因为C++本身已具备更优秀的机制来处理这类特定场景）。

在本章中，我们将重点探讨作者认为极其实用、却始终未能以原生形态进入C++标准的某些C语言特性。

\mySubsubsection{11.1.1}{参数列表的魔法}

让我们从一个最简单的函数开始：int foo()。这个函数虽然简单，但确实能完成它的工作（无论那是什么）。

当用C语言编译时，空参数列表意味着该函数可以接受不确定数量的参数——如果向函数传递参数，这可能导致歧义和潜在错误，因为编译器不会强制参数约束。为了在C中明确表示函数不接受任何参数，我们必须在参数列表中使用void，即int foo(void)，这明确指出函数不接受任何参数，传递参数将导致编译错误。

相比之下，C++简化了这一设计：将空参数列表视为等同于void。也就是说，在C++中，int foo()和int foo(void)都表示函数不接受任何参数，使得void在C++中成为可选项。这让C++的语法更简洁——无参数的函数可以直接用空括号声明。虽然C仍需要void来保证清晰和正确性，但C++允许两种形式（通常习惯省略void而使用更简洁的int foo()）。很巧妙，不是吗？

不过，如果我们想给函数添加参数呢？让我们将其修改为int foo(int array[static 10])的形式。这个int foo(int array[static 10])声明是C99引入的特性，它为编译器提供了关于函数参数的额外信息（特别是处理数组时）。

这里，数组参数中的 static 关键字告诉编译器：调用该函数时，传入的数组必须至少包含 10 个元素。数字 10 指定了传递给函数的数组的最小尺寸，这能帮助编译器做出某些假设（例如基于数组的确定尺寸进行优化）。

此外，当以这种方式在数组参数中使用 static 时，编译器会假定该数组指针不可能为 NULL。因为空指针意味着没有任何有效元素，这将违反"数组必须至少包含 10 个元素"的条件。这提供了额外的安全性和明确性——函数无需在操作前检查数组是否为 NULL，从而减少了运行时开销。

较新版本的 Clang（基本上 3.1.0 以上）甚至会在你用臭名昭著的 NULL 指针调用这种特殊声明的函数时发出警告：

\begin{shell}
warning: null passed to a callee which requires a non-null argument
\end{shell}

遗憾的是，这个非常实用的特性并未被纳入任何C++标准，而且并非所有现代C编译器都能支持它（无论指定哪个C标准，我们都无法让MSVC成功编译这段代码）。不过，对于不针对这些平台的程序员来说，这确实可能在需要时派上大用场。

另一个仅限于C程序员圈子的实用特性是C99引入的restrict关键字。这是一个类型限定符，为编译器提供指针相关内存访问的优化提示。它告诉编译器：被restrict修饰的指针是当前作用域内访问所指对象（内存）的唯一途径。这使得编译器可以进行激进优化，因为它可以假设没有其他指针会别名化或引用同一块内存。

当你在指针上使用restrict限定符时，实际上是在向编译器承诺：在该指针的生命周期内，其指向的对象不会被任何其他指针访问。这使得编译器能够生成更高效的代码——避免由于潜在的别名问题（多个指针指向同一内存）而导致的不必要内存重加载或重新获取操作。

如果没有restrict，编译器就必须假定任意两个指针都可能引用同一内存，这会限制其代码优化能力。例如，考虑以下代码：

\begin{cpp}
void update1(int *a, int *b) {
  *a = *a + *b;
  *b = *b + *a;
}
\end{cpp}

在这种情况下，编译器必须假定a和b可能存在别名关系（即可能指向同一内存地址），因此它可能会每次都从内存重新加载a或b的值以确保正确性。

而使用restrict限定符的版本则不同：

\begin{cpp}
void update2(int *restrict a, int *restrict b) {
  *a = *a + *b;
  *b = *b + *a;
}
\end{cpp}

此时我们已明确告知编译器 *a 和 *b 不存在别名关系，因此编译器可以放心地进行优化，无需担心内存别名问题。

以下是 GCC 14.2 使用 -O3 优化级别为这两个不同函数生成的汇编代码对比（附简要说明）：

\begin{shell}
update1:
  mov eax, DWORD PTR [rsi]; Load b from [rsi] into eax
  add eax, DWORD PTR [rdi]; Add a from [rdi] to eax
  mov DWORD PTR [rdi], eax; Store eax into [rdi] (a)
  add DWORD PTR [rsi], eax; Add eax to [rsi] (b)
  ret ; Return
\end{shell}

这是另一个：

\begin{shell}
update2:
  mov eax, DWORD PTR [rsi]; Load b from [rsi] into eax
  mov edx, DWORD PTR [rdi]; Load a from [rdi] into edx
  add edx, eax ; eax + edx (result in edx) - a
  add eax, edx ; edx + eax (result in eax) - b
  mov DWORD PTR [rdi], edx; Store edx into [rdi] - a
  mov DWORD PTR [rsi], eax; Store eax into [rsi] - b
  ret ; Return
\end{shell}

出人意料的是，使用了restrict的版本反而多了几条指令，但只要仔细查看生成的代码，就能明显看出restrict关键字的效果。假设函数参数存放在[rsi]和[rdi]指向的内存位置：第一个版本（无restrict）必须在内存中完成所有加法运算，导致代码效率稍低；而第二个版本则能将这类耗时操作转换为两个超快的寄存器加法。

这两者还有个关键区别：第二个版本（update2，带restrict）可以假设第二个参数的值在第一次操作后不会改变，因此精心设计的寄存器初始化和加法操作能充分发挥作用。而第一个版本必须考虑a = *a + *b;运算可能会改变b的值（位于[rsi]），因此它需要在内存中执行操作，始终确保后续运算能获取最新值。

虽然对于这类简单加法运算而言，效果可能不如本书无法容纳的更复杂示例那样显著，但我们已有足够证据表明restrict关键字确实会影响生成的代码。遗憾的是，这个特性同样未能进入C++标准。

不过，对C++及其与C兼容性不足的批评就到此为止吧。它们本就不是竞争关系，而是相辅相成的存在。现在，让我们转向更有趣的领域：C++真的能自我兼容吗？











