
我们这位朋友乔的冒险故事还在继续。在他刚领悟到类成员的正确排序并非字母顺序后不久，就接到一个需要并行执行代码的任务。由于他仅通过TikTok上的入门教程学习了线程相关知识，便自信满满地提交了以下代码（请读者见谅：由于版权和知识产权诉讼的限制，我们无法展示让整个开发团队花费两周时间调试的原始代码，以下示例仅试图还原乔"成功"实现的场景）：

\begin{cpp}
#include <cstdio>
#include <thread>
#include <chrono>
using namespace std::chrono_literals;
struct bar {
  bar() : i(new long long) {
    *i = 0; printf("bar::bar()\n");
  }
  ~bar() {printf("bar::~bar()\n"); delete i; i = nullptr;}
  void serve() {
    while(true) {
      (*i)++;
      if(*i % 1024768 == 0) {
        std::this_thread::sleep_for(200ms);
        (*i) = 0;
        printf("."); fflush(stdout);
      }
      if(stopRequest) break;
    }
  }

  long long* i = nullptr;
  bool stopRequest = false;
};

struct foo {
  foo() : thread(&foo::threadFunc, this) {
    printf("foo::foo()\n");
  }

  ~foo() {
    printf("foo::~foo()\n"); b.stopRequest = true;
  }

  void threadFunc() {
    b.serve();
  }

  std::jthread thread;
  bar b;
};

int main() {
  foo f;
  std::this_thread::sleep_for(2000ms);
  printf("main returns\n");
  return 0;
}
\end{cpp}


这段C++代码试图还原乔制造的简易多线程混乱场景。程序定义了两个结构体：

bar结构体：

\begin{itemize}
\item 
管理动态分配的long long型变量i（作为计数器）

\item 
在serve()方法中持续递增计数器

\item 
当计数达到1024768次时（忽略这个数字恰巧是1024x768分辨率的事实）：
\begin{itemize}
\item 
暂停200毫秒

\item 
重置计数器

\item 
输出一个点（实际应用中有其他操作）
\end{itemize}

\item 
构造函数/析构函数包含调试信息输出

注意：此处使用原始指针而非智能指针（原因成谜）
\end{itemize}

foo结构体：

\begin{itemize}
\item 
负责启动/停止执行bar::serve()的线程

\item 
使用std::jthread管理线程生命周期

\item 
通过stopRequest标志位控制线程退出

\item 
实际工程中经过两周调试才稳定（团队决定不再提及这段代码）
\end{itemize}

主函数流程：

\begin{itemize}
\item 
创建foo实例自动启动线程

\item 
主线程休眠2秒（原版无此休眠，实际有复杂操作）

\item 
注意：此示例代码仅为演示崩溃场景，非线程同步最佳实践
\end{itemize}

各位资深C++程序员请注意：请勿纠结这段示例代码中简陋的线程同步方式，或是其内存分配/释放的实现细节——因为这段代码存在的唯一目的就是演示崩溃场景。对于std::jthread，标准库其实提供了完善的管理机制（如std::stop\_source和std::stop\_token），建议阅读相关文档学习规范用法，现在暂且让乔继续用他的"天真"线程方案吃点苦头。

在作者的Linux系统上，执行结果通常如下所示：

\begin{shell}
> $ ./a.out
bar::bar()
foo::foo()
.........main returns
foo::~foo()
bar::~bar()
\end{shell}

然而在某些情况下，程序会输出如下结果：

\begin{shell}
> $ ./a.out
bar::bar()
foo::foo()
.........main returns
foo::~foo()
bar::~bar()
[1]    93622 segmentation fault (core dumped) ./a.out
\end{shell}

乔也遇到了同样的问题。程序偶尔会在退出时失控崩溃。起初这似乎无伤大雅——毕竟程序在结束时崩溃，也算是一种"结束"。但当他将这段代码整合到更大的模块中后，真正的混乱开始了，最终演变成前文提及的、持续两周的调试噩梦。

根本原因其实很简单。编程大师吉米在查阅他随身携带的C++标准文档（特别是[class.dtor]章节）后发现：

\begin{shell}
在析构函数执行完函数体并销毁函数体内定义的自动存储期对象后，类X的析构函数会依次调用：

1.X的非静态数据成员（非变体成员）的析构函数

2.X的非虚直接基类的析构函数

3.若X是最派生类，还会调用虚基类的析构函数

关键规则：

· 所有析构函数调用都视为通过限定名引用（忽略派生类中可能存在的虚析构函数覆盖）

· 基类和成员的析构顺序与其构造完成顺序严格相反

· 数组元素的析构顺序与其构造顺序相反

特别注意：
析构函数中的return语句不会立即返回调用方，在控制权转移前，必须确保所有成员和基类的析构函数都已完成调用。
\end{shell}

关键在于，对象的析构顺序与其构造顺序严格相反——就像它们被构造时压入栈中，而在析构时又以优雅的逆序弹出。

导致错误行为的罪魁祸首很快被锁定为以下两点：

\begin{cpp}
std::jthread thread;
\end{cpp}

\begin{cpp}
bar b;
\end{cpp}

问题出在构造顺序上：线程对象被创建后立即启动执行\verb|threadFunc(){ b.serve(); }|，而此时bar b对象尚未完成构造。根据C++的析构规则，退出时bar b会先被销毁，而此时线程可能仍在执行耗时操作——导致线程访问了一个已被销毁的对象。

虽然从线程对象创建、线程启动到bar b构造完成的时间差微乎其微（几乎不可能在构造阶段发现问题），但我们可以通过重写bar的构造函数来暴露问题：

\begin{cpp}
bar() { std::this_thread::sleep_for(200ms);
  i = new long long; *i = 0; printf("bar::bar()\n ");}
\end{cpp}

通过这个案例，我们可以清楚地看到：当线程开始操作对象时，该对象的构造过程尚未完全结束。这个问题其实很容易解决——只需调整类成员的声明顺序：

\begin{cpp}
bar b;
std::jthread thread;
\end{cpp}

多线程是C++中一个既强大又危险的特性。虽然能带来性能提升，但也引入了额外的复杂性。要编写正确高效的多线程代码，必须谨慎处理以下问题：

\begin{itemize}
\item 
线程间的同步与协调

\item 
竞态条件(race conditions)

\item 
死锁(deadlocks)

\item 
非确定性行为

\item 
调试困境（线程被调试器暂停时无法复现问题）
\end{itemize}

有时，程序能否正常运行，竟然完全取决于类成员的声明顺序。不过现在，是时候告别乔和他的伙伴们了——但愿他们的4A大作能顺利发布——让我们把注意力转向其他主题吧。





















