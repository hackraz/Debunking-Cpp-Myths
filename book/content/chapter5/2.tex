
在BigGameDev公司工作时，乔又接到一个与角色开发相关的任务(这里指的是游戏角色，不是他个人的性格发展)。这个任务很简单：只需要返回一个格式化字符串，显示角色当前的生命值。

为此，乔创建了以下类：

\begin{cpp}
#include <string>
#include <format>
#include <iostream>
#include <string_view>

struct life_point_tracker {
  life_point_tracker(std::string_view player, int points) {
    m_player = player;
    m_points = points;
    m_result = std::format("{} has {} LPs",
    m_player, m_points);
  }

  std::string get_data() const {
    return m_result;
  }

private:
  std::string m_result {""};
  std::string m_player {""};
  int m_points {0};
};

int main() {
  life_point_tracker lpt("Joe", 120);
  std::cout << lpt.get_data();
}
\end{cpp}


这个实现非常直观：接收输入数据并存储结果以便后续访问。乔现在很开心——虽然不再坚持字母排序(经过上次对齐问题的教训)，但他按类型合理组织了类成员。他还采用了现代C++特性，比如format库和成员变量就地初始化(不过string类型其实默认构造函数就会初始化为空字符串，所以对它们来说这个特性没那么必要，但对int类型就很有用了)。

乔正准备直接提交代码到代码库，但理智占了上风。他先做了快速测试，确认一切正常后，请主管Jimmy(就是上一节提到的那位)做了代码审查。

代码看起来没问题：能编译通过，功能也符合要求。但Jimmy提出了两个小建议：

\begin{itemize}
\item 
应该在构造函数的初始化列表中赋值，而不是在构造函数体内赋值

\item 
既然要用初始化列表，不如把成员变量声明为const，这样编译器可能会做一些额外优化
\end{itemize}

因此，代码应该改为这样：

\begin{cpp}
const std::string m_result {""};
const std::string m_player {""};
const int m_points {0};
\end{cpp}

在C++中，构造函数使用初始化列表相比在函数体内赋值有几个关键优势：

\begin{itemize}
\item 
效率更高：直接初始化成员变量，避免先默认初始化再赋值

\item 
必要性：const成员和引用成员必须在初始化列表中初始化

\item 
顺序保证：严格遵循成员声明顺序进行初始化
\end{itemize}

乔愉快地修改了代码，由于改动不大，他"忘记"了测试就直接提交了以下修改：

\begin{cpp}
life_point_tracker(std::string_view player, int points)
: m_player(player), m_points(points),
  m_result(std::format("{} has {} LPs", m_player, m_points)) {}
\end{cpp}

很快他就收到了回复——但出乎意料,不是预期的表扬。"乔,你测试过这段代码吗?"他不得不承认觉得没必要测试,毕竟只是: 

\begin{itemize}
\item 
把几行代码位置上移

\item 
把等号改成括号

\item 
其他几乎没变
\end{itemize}

"哦，我明白了..."Jimmy说着，从后裤袋掏出一份崭新的最新版C++标准文档。

标准在[class.base.init]章节明确指出：

\begin{shell}
在非委托构造函数中，初始化按以下顺序执行：

首先(仅针对最派生类的构造函数)：

虚基类初始化：按照基类有向无环图的深度优先、从左到右遍历顺序进行初始化

"从左到右"指派生类base-specifier-list中基类的声明顺序

接着，直接基类初始化：按照base-specifier-list中的声明顺序初始化(与mem-initializers中的顺序无关)

然后，非静态数据成员初始化：按照类定义中的成员声明顺序初始化(同样与mem-initializers中的顺序无关)

最后，执行构造函数体的复合语句
\end{shell}

这意味着在实践中，无论你在初始化列表中如何排列成员变量的初始化顺序，它们最终都会按照类定义中的声明顺序进行初始化。因此，m\_result会首先被初始化，而此时它依赖的另外两个数据成员尚未初始化——最好的情况是导致未定义行为，最坏的情况是测试时得到默认值，而生产环境代码会灾难性地崩溃。

现在，掌握了这些知识的乔终于能够按时交付符合最高标准的代码：

\begin{cpp}
life_point_tracker(std::string_view player, int points)
try :
  m_result(std::format("{} has {} LPs", player, points)),
  m_player(player),
  m_points(points)
{ 
}
catch(...) {throw;}
\end{cpp}

他领悟到：虽然初始化列表在某些情况下是天赐良物，但若忽视C++标准规定的基本规则，也可能将代码推向编译器地狱的深渊。C++标准强制要求成员变量必须按照类声明顺序初始化(而非初始化列表中的顺序)，这种设计确保了对象构造过程的一致性和可预测性——毕竟当没有初始化列表或只初始化部分成员时，仍需保证初始化顺序的确定性。

这种初始化顺序直接影响析构顺序(析构顺序与初始化顺序相反)。通过确保成员按初始化逆序析构，可以保证在析构阶段依赖其他成员的变量仍处于有效状态，这种一致的清理流程能预防潜在错误，维护对象生命周期的完整性。

基于这一语言特性要求，我们可以利用C++20引入的"指定初始化器"(designated initializers)特性，给出更优雅简洁的解决方案。简化后的结构如下：

\begin{cpp}
struct life_point_tracker {
  std::string get_data() const {
  return m_result;
  }
  std::string m_player {"Nameless"};
  int m_points {0};
  const std::string m_result
    {std::format("{} has {} LPs", m_player, m_points)};
};
\end{cpp}

这些简单结构满足作为聚合体(aggregate)的要求——这是使用指定初始化器特性的前提条件。如你所见，m\_result成员在自身构造时就能正确使用已初始化的m\_player和m\_points成员。在使用该类的场景中，我们只需这样做：

\begin{cpp}
int main(int argc, char **argv) {
  life_point_tracker lpt {
    .m_player = "Joe",
    .m_points = 120
  };
  std::cout << lpt.get_data();
}
\end{cpp}

通过这一便利特性，我们可以显式指定每个成员的初始化值(当需要初始化多个整型成员时尤其有用)。该特性强制要求成员必须按声明顺序初始化，从而提升代码可读性和可维护性。唯一缺点是必须将类降级为聚合体——这意味着不能有虚函数、自定义构造函数或封装特性，牺牲了C++类的诸多强大功能。不过既然乔觉得够用，我们也可以接受这种妥协。


