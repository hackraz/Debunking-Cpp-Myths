到目前为止，我们已经看到一些情况：是否遵循标准完全取决于开发者的个人选择。他们可以选择自己的平台，使用自己喜爱的编译器所提供的扩展功能，或者坚持使用纯粹的标准 C++。然而，在现实世界的广阔天地中，还存在着某些特定的情形——由于环境对我们施加了某些限制，导致我们无法使用 C++ 标准中的一些特性，从而无法完全符合标准。

不考虑那些令人不适的情形——当我们必须维护几十年前遗留下来的代码，这些代码写于 C++ 的黄金年代(也就是在标准化委员会接管之前、尚未因强制要求符合标准而“毁掉所有乐趣”的时代)，以避免像 BASIC 那样导致各种 C++ 方言泛滥失控的局面——我们有时会遇到一些无法控制的情况，使得我们无法使用完整的 C++ 标准特性。例如，某些项目可能明确禁止使用异常；有些环境可能缺乏对内存分配的正确支持；还有一些环境则依然要求我们必须直接向硬件地址写入数据，才能让某些功能得以实现。不过，最后这种情况其实也可以用符合标准的方式来实现。

例如，某些嵌入式系统就积极鼓励使用其平台特定的汇编指令。我们知道，在当今的 C++ 中，并不存在所谓平台无关的汇编语言——因为那已经是我们可以触及的最低层了。再往下就是纯十六进制的机器码，但那个需要直接编写机器代码的时代早已一去不复返了。

也可能存在这样的情形：硬件对我们代码行为的要求中包含了必须具备确定性行为。这也就意味着，异常机制被排除在外了(因为谁会希望自己在代码执行的每一纳秒都无法准确追踪其执行流程呢？)，同时内存分配也被排除在外(因为存在分配延迟、内存碎片以及诸多其他问题，导致你的代码再次无法表现出确定性的行为)。因此，很大一部分 C++ 标准特性在这种情况下就不得不被舍弃了。

有一些解决方案专门应对嵌入式系统中的内存分配问题，例如使用内存池、对象池、编译期内存分配以及其他各种资源管理策略，其中一些方法甚至可能是特定于平台的。而至于异常机制，情况则更为复杂。在比雅尼·斯特劳斯特鲁普(Bjarne Stroustrup)的优秀论文中\footnote{\url{https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1947r0.pdf}}，他探讨了用诸如“确定性异常”等替代方案取代 C++ 异常所带来的挑战、成本与风险。然而正如这篇论文所总结的那样，目前尚无明确的优势可以说明我们应当用其他机制取代现有的异常处理机制。那样做只会进一步加剧 C++ 开发社区的碎片化现状，而这种现象已经够多了。相反，论文主张应将重点放在增强当前的异常处理系统上，而不是通过引入新的机制来使语言变得更加复杂。作者强调，尽管异常机制并不完美，但它在过去几十年中有效地服务了无数开发者。

























