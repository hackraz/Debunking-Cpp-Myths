现在回头盯着看已经够了。让我们从不同的方向看一下,考虑一个编译器,它曾经是 C++ 王,但随着时间的推移,它的光芒逐渐褪去。OpenWatcom 是一个开源的集成开发环境和译器套件,适用于 C 和 C++(以及 Fortran,但该语言在本书中不是重点),最初由 Watc m International Corporation 开发,并由 Sybase 于 2003 年作为开源发布。

它支持多种作系统,包括 DOS、Windows、OS/2 以及 Linux,并且是有兴趣为复古平台创有趣、空闲时间项目的开发者的实际编译器。

不一定是为了钱,而是为了当他们站在 80x25 屏幕前时那种甜蜜的怀旧感在人的脊椎上颤。也许这就是当今大多数高级开发者在巨大的 WQUXGA(或更大)屏幕上使用在 6x4 窗的终端中运行的 VI 编辑器网格的原因。

但是,让我们回到 OpenWatcom 编译器。在浏览项目 2 的发行说明时,我们遇到了以下内容容我这么说,这是非常有趣的短语(在与 10.0 版的主要区别部分,第 29 项):

\begin{shell}
我们复制了一个 Microsoft Visual C++ 的扩展功能，这个功能在解析 Windows 95 SDK 头文件时是必需的。

示例：

typedef struct S {
} S, const *CSP;

^^^^^ - 这种写法在 ISO C 或 ISO C++ 中是不允许的
\end{shell}

嗯......什么?我刚才是否正确地阅读了 Visual C++ 有一个允许编译非标准代码的扩展? 

是的,我们实际上没看错。以下简短的演示代码序列目前不应使用任何主要的 C++ 编译器行编译,但 Visual C++(以及 OpenWatcom\footnote{\url{https://open-watcom.github.io/open-watcom-v2-wikidocs/c_readme.html}} 的 C++ 编译器,根据他们的评论)除外:

\begin{cpp}
#include <iostream>
typedef struct S {
  int a;
} S, const *CSP;
int main() {
  S s1; s1.a = 1;
  CSP ps1 = &s1;
  std::cout << ps1->a;
}
\end{cpp}

...由于一些谜团,作者无法破译,代码序列也被 ICC(英特尔强大但遗憾地停产的 C++ 编器)的多个版本所接受。那么,我们可以再问以下问题:既然一个主要的、两个相对深的编译器都接受这种代码,这是否意味着我们应该使用它呢?它是标准的吗? 

第二个问题的答案是否定的。然而,对于第一个,它更加微妙。 这是因为在回答之前,我必须再次考虑可能影响开发决策的背景、要求和其他相关因素。

我们想尽可能地坚持标准的 C++ 吗?是否有可能在不扩展使用供应商特定的扩展的情况下供所需的解决方案?我们是否受编译器或作系统的约束,我们是否不担心需要访问国外

使用采用 Microsoft 平台提供的 C++ 托管扩展会给我们省去很多麻烦,还是我们宁愿坚持使我们熟悉的旧语法(和类型)? 

Microsoft 以为 C 和 C++ 语言提供特定于平台的扩展而闻名,以至于有一整节专门介绍特定 Microsoft 的 C++ 关键字\footnote{\url{https://learn.microsoft.com/en-us/cpp/cpp/keywords-cpp?view=msvc-170}}。这告诉我们,非标准 C++ 是有市场的,而且是有正当理由的因为其中一些扩展非常方便,但代价是将我们自己绑定到平台、编译器和工具链。

Microsoft 扩展之一显示在 \_\_declspec 关键字中。C 和 C++ 中的 \_\_declspec 关键字是 Microsot 扩展的 C++ 语法的一部分,它允许开发人员为某些 C++ 构造指定特定于Microsoft存储类性。

此关键字提供对 DLL 导出和内存对齐等行为的额外控制,这些行为未包含在标准 ANSI 关字(如 static 和 extern)中。通过使用 \_\_declspec,开发人员可以轻松地将特定于Microsof 自己的编译器的这些功能(看啊:惊喜接踵而至)应用到他们的代码中,从而增强其代码功能和性能,如以下代码序列所示:

\begin{cpp}
struct person {
  void set_age(int page) { m_age = page; }
  int get_age() const { return m_age; }
  __declspec (property(get = get_age, put = set_age)) int age;
  person() = default;
private:
  int m_age;
};
int main() {
  person joe;
  joe.age = 12;
  std::cout << "Hello " << joe.age;
}
\end{cpp}

使用 Microsoft 的 \_\_declspec(property(...)) 语法,前面的代码序列创建了一个 age 属性该属性允许通过提供的方法与 m\_age 进行间接交互,正确封装了 age 数据,同时提供了问和修改它的简化接口。

可以通过 \_\_declspec 扩展利用的属性列表很长且实用,\_\_declspec编译器开发领域似乎也很引人。事实上,它非常吸引人,以至于 Clang 提供了一个专门用于理解这个特定于 Microsoft 的扩展的论点。 这个标志 -fdeclspec 使得也可以在 Clang 编译的代码中使用 \_\_declspec 键字。因此,问题自然而然地出现了:这是否不再是 Microsoft 特定的扩展,或者我们正见证跨平台功能的出现?

在铁杆 C++ 开发者圈子里,一个仍然被认为是禁忌的事实是,在现实生活中,需要编写真的跨平台代码的情况很少见。大多数开发者为特定公司工作,开发或支持特定产品。他主要使用一个作系统,一个编译器工具链,遵守雇主施加的限制,并愉快地使用编译器持的所有扩展来编译代码。

这并不意味着他们不明确地想要编写符合标准的 C++ 代码。不,相反,我相信他们编写了们能想到的最高质量代码。这只是意味着他们只使用特定编译器提供的可能性:他们必使用的编译器。在他们的下一家公司,他们很有可能使用在不同作系统上运行的不同编器,从而忘记了他们的前编译器在前位置提供的所有优势。 这是因为特定于编译器的语和扩展并不专门绑定到一个编译器。

让我们考虑以下代码示例,例如:

\begin{cpp}
char arr[6] = {'a', 'b', "cde"};
\end{cpp}

除了伤害我们的眼睛之外,这个序列显然是尽可能的标准和不合规的。 谁会尝试像这样初化一个包含 6 个字符的数组呢?但是,Microsoft Visual C++ 编译器很乐意对其进行消化让我们从几个普通字符开始,当我们厌倦了输入所有的撇号和逗号时,我们就会把其他有内容都放在一个常量字符串文本中,因为为什么不呢?它非常聪明,检测数组请求的小并将其与零件的累积长度匹配,如果有任何不匹配,则发出错误信号。

Microsoft 的 C++ 编译器在添加标准中没有的功能或允许使用会破坏语言律师舌头的代码方,是一个非常创新的编译器。例如,让我们看一下以下代码段:

\begin{cpp}
class person {
public:
  int age;
  class {
  public:
    std::string name;
  };
}
\end{cpp}

此代码序列绝非标准 C++。它的存在甚至允许我们编写如下所示的代码：

\begin{cpp}
int main() {
  person joe;
  joe.name = "Joe";
  std::cout << "Hello " << joe.name;
}
\end{cpp}

前面的示例在使用 Microsoft 自己的 C++ 编译器进行编译和运行时没有任何问题。请仔细观包含 name member 的匿名类是一个具有构造函数的对象。这是一个具有构造函数、析构数和许多其他有趣功能的对象。这是 Microsoft 对标准的另一个偏差(如果我可以这么说话,非常方便),因为匿名联合是众所周知的 C++ 野兽。但是,匿名结构仅存在于 C 语中(从 C11 开始),没有其他编译器接受上述代码。

顺便说一句,如果你不熟悉 C 语言中匿名结构的概念,它们是简化嵌套结构声明的有用功。当其他地方不需要内部结构时,它们不需要命名内部结构,并且它们使代码更加简洁可读。 虽然成员包含在结构中,但仍可以直接访问它们。通过将相关字段封装在匿名结中,并在这些成员中引入逻辑块,代码与不必要的类型定义的混乱变得不那么令人不知措。




