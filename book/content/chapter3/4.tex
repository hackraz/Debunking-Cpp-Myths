
似乎有一件事能够跨越技术栈和文化差异，将开发者们团结在一起：那就是对递归笑话的喜爱。在开发者的思维中，似乎天生就有一种对某种形式对称性的欣赏。当谈到编程语言与编程范式时，你很难找到一种比“能理解自身”的语言更具对称美感的概念了。

这种思想对应的编程范式被称为 元编程，而将这一理念推向极致的语言则被称为 同像性语言。这类语言允许程序将其自身的结构当作数据来操作，从而实现对程序本身的分析、变换甚至执行。

具备这种特性的典型语言包括 Lisp 及其众多变体，其中最新的代表是 Clojure。这些语言的设计使得代码本身就是一种可以直接操作的数据结构，极大提升了灵活性和抽象能力。

元编程是一种极为强大的工具，但同时也极具挑战性，在大型项目中如果使用不当，很容易引入复杂性和维护难题。现代编程语言中也包含一些与元编程相关的特性，例如插桩、反射以及动态执行指令等。然而，除了注解等少数功能外，这些机制在实际开发中的使用频率并不高。

但 C++ 是一个例外。

元编程的一个核心思想是：将运行时的计算尽可能提前到编译时进行。而 C++ 通过 模板元编程 完美地拥抱了这一理念。随着语言的发展，C++11 引入了 constexpr，C++20 进一步加入了 consteval，这使得编译期计算的表达更加自然、安全且易于使用。

一个经典的例子是阶乘函数的实现。一个在运行时计算阶乘的递归实现如下所示：

\begin{cpp}
int factorial(const int number){
  if(number == 0) return 1;
  return number * factorial(number - 1);
}
\end{cpp}

同样的功能也可以通过模板元编程实现， C++ 模板的一个特性是：它们不仅可以接受类型作为参数，还可以接受值作为模板参数。我们既可以定义一个通用模板（例如接受任意整数的模板），也可以为特定值提供特化版本。基于此，我们可以写出如下的阶乘模板：

\begin{cpp}
template<int number>
struct Factorial {
  enum { value = number * Factorial<number - 1>::value};
};

template<>
struct Factorial<0>{
  enum {value = 1};
}
\end{cpp}

这个实现与之前的递归版本逻辑相同，但不同之处在于：当我们调用 Factorial<25>::value 时，整个计算过程会在编译期间完成，而不是在运行时执行。

从 C++11 开始，广义常量表达式的引入可以不再依赖模板，而是改用更直观的 constexpr 和 consteval 来明确告诉编译器哪些函数或值应该在编译期求值。下面是使用 constexpr 实现的简化版阶乘函数：

\begin{cpp}
constexpr int factorial(const int number) {
  return (number == 0) ? 1 : (number * factorial(number - 1));
}
\end{cpp}

这些元编程技术为 C++ 开发者提供了更大的自由度，使我们可以在运行时效率与编译时优化之间做出权衡。它本质上是在CPU 时间与可执行文件大小之间的平衡点。如果你有充足的内存空间，但又希望某些计算尽可能快速完成，那么将结果预先缓存在可执行文件中便是一个理想的选择，而这正是 constexpr 和 consteval 所擅长的领域。

但这还不是全部。我们甚至可以编写出在编译阶段就能被证明正确的 C++ 程序。要做到这一点，我们需要充分发挥 强类型系统 的潜力，构建出具有高度表达力和安全性的一类代码 --- 这也是现代 C++ 元编程探索的方向之一。




