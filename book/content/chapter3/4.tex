
似乎有一件事能够将开发者们团结起来，无论他们之间有多么不同：那就是对递归笑话的喜爱。开发者的思维中似乎有一种对某种类型对称性的欣赏。当谈到编程语言和编程范式时，你很难找到一种比“能理解自身”的语言更具对称性的概念了。

对应的编程范式被称为元编程(metaprogramming)，而将这一思想发挥到极致的编程语言被称为同像性语言(homoiconic)。这意味着一个程序可以将其自身或其他程序的表示当作数据一样进行操作。具备这种特性的编程语言包括 Lisp 及其衍生方言，最新的代表是 Clojure。

元编程非常强大，但也极难掌握，并且在大型项目中可能引入大量问题。现代语言中有一些与元编程相关的特性，比如插桩(instrumentation)、反射(reflection)以及指令的动态执行等。但除了使用注解(annotations)之外，这些功能在实际中很少被用到。

然而，C++ 是个例外。元编程的一个核心特征是将运行时计算转移到编译时进行，而 C++ 通过模板元编程(template metaprogramming)完全拥抱了这一理念。在语言的较新版本中，随着 constexpr 和 consteval 的引入，编译时计算的实现变得更加简单易用。

这种技术的一个典型例子是阶乘函数的实现。一个在运行时计算的递归阶乘函数看起来像这样：

\begin{cpp}
int factorial(const int number){
  if(number == 0) return 1;
  return number * factorial(number - 1);
}
\end{cpp}

同样的功能也可以使用模板元编程来实现。也许一个不太为人所知的 C++ 模板特性是：它们不仅可以接受类型作为参数，还可以接受值作为参数。此外，我们可以既提供一个通用模板(例如，接受任何整数值作为参数的模板)，也可以提供一个针对特定值的特化版本。在我们的例子中，可以实现一个接受整数参数的阶乘模板，并为值 0 提供一个特化版本，最终得到如下代码：

\begin{cpp}
template<int number>
struct Factorial {
  enum { value = number * Factorial<number - 1>::value};
};

template<>
struct Factorial<0>{
  enum {value = 1};
}
\end{cpp}

这个实现与之前的递归实现达到了相同的目标，只不过例如对 factorial<25> 的调用将会在编译时完成计算，而不是在运行时。从 C++11 开始，随着广义常量表达式(generalized constant expressions)的引入，我们可以完全避免使用模板，转而使用 constexpr 和 consteval 来告诉编译器哪些值需要在编译时进行计算。下面是使用常量表达式实现的简化版代码：

\begin{cpp}
constexpr int factorial(const int number) {
  return (number == 0) ? 1 : (number * factorial(number - 1));
}
\end{cpp}

这些 C++ 开发者可使用的元编程技术，为我们提供了在编译时与运行时之间做出决策的更大灵活性。它们提供了一种在 CPU 运算时间与可执行文件大小之间的权衡。如果你有充足的内存可用，但计算任务需要非常快速地完成，那么将结果缓存在可执行文件中可能是一个理想的选择，此时 constexpr 和 consteval 就会成为你的得力工具。

但可能性远不止于此。我们还可以编写出在编译时就能被证明是正确的 C++ 程序。要做到这一点，我们只需将强类型(strong types)发挥到极致。




