
几年前，我曾带领一个团队使用一种名为 Groovy 的语言和名为 Grails 的框架开发了几个 Web 应用程序。Groovy 是一门可选类型化（optionally typed）和动态类型（dynamic）的语言，这意味着它在运行时分配类型，但你也可以为编译器提供类型提示。它也可以被静态编译，而且由于它构建在 JVM 之上，所以最终的代码会变成一个 Java 单元。

我在之前的 Web 项目中注意到，类型在系统的边界上非常有用，比如用于检查请求参数、与数据库交互以及其他 I/O 操作。但在 Web 应用程序的核心逻辑中使用类型往往会带来更多的复杂性。我们经常不得不修改代码或编写额外的代码，以适应对已有功能的新使用方式。因为 Web 应用的用户经常会发现某个场景很有用，并希望它能在其他上下文或其他类型的数据中也起作用。因此，从一开始我就决定：我们只在请求验证中使用类型，以确保安全性与正确性；也在与外部系统交互时使用类型，以确保简单性。但在核心逻辑中，我们不会使用类型。

我们的计划一直是采用一套稳健的自动化测试策略，以确保所有代码通过测试来证明其有效性。我原本预计缺少类型会导致我们需要编写更多的测试，但我却得到了一个意外的发现：测试数量其实差不多，但代码量减少了。而且，由于我们没有使用类型，这就迫使我们在命名上更加小心谨慎——因为对于程序员来说，名字就是我们唯一能用来理解函数或变量用途的线索。

直到今天，这仍然是我最喜欢的编程风格。我希望按照自己的意愿、尽可能富有表达力地编写代码，然后让编译器去处理类型问题。你可以将这种方法看作是极端多态（extreme polymorphism）：如果你传入了一个拥有所需方法的类型的变量，不管这个变量的具体类型是什么，代码都应该可以正常工作。这种风格并不是适合所有人，因为它只有在配合特定的设计经验和实践时才明显有效。但它是一种你可以尝试探索的风格。不过，第一步的障碍就是要放下对编译器行为的控制欲望——这对于习惯了细节导向的 C++ 程序员来说，可能是一件难以做到的事情。

那么，在 C++ 中如何实现这种风格呢？幸运的是，从 C++11 开始引入了 auto 关键字，并在后续的标准中逐步增强了它的功能。但另一方面，C++ 在动态类型方面并不像 Groovy 那样灵活，所以我偶尔还是需要用到模板。

首先，让我用你能写出的最具多态性的函数来让你大吃一惊：

\begin{cpp}
auto identity(auto value){ return value;}

TEST_CASE("Identity"){
  CHECK_EQ(1, identity(1));
  CHECK_EQ("asdfasdf", identity("asdfasdf"));
  CHECK_EQ(vector{1, 2, 3}, identity(vector{1, 2, 3}));
}
\end{cpp}

不管你传入什么参数，这个函数都能正常工作。这不是很简洁吗？想象一下，如果你的系统核心中有一系列这样的函数，无需修改就可以直接使用。对我来说，这听起来就是一个理想的编程环境。然而，现实比这要复杂得多，程序需要的功能远远不止恒等函数这么简单。

让我们来看一个稍微复杂一点的例子：判断一个字符串是否是回文（palindrome），也就是正着读和反着读都是一样的字符串。一个简单的 C++ 实现方式是：获取该字符串，使用 std::reverse\_copy 将其反转，然后将原字符串与其反转版本进行比较：

\begin{cpp}
bool isStringPalindrome(std::string value){
  std::vector<char> characters(value.begin(), value.end());
  std::vector<char> reversedCharacters;
  std::reverse_copy(characters.begin(), characters.end(), std::back_
  insert_iterator(reversedCharacters));
  return characters == reversedCharacters;
}

TEST_CASE("Palindrome"){
  CHECK(isStringPalindrome("asddsa"));
  CHECK(isStringPalindrome("12321"));
  CHECK_FALSE(isStringPalindrome("123123"));
  CHECK_FALSE(isStringPalindrome("asd"));
}
\end{cpp}

如果我们让这段代码对类型不再那么“感兴趣”，会怎么样呢？首先，我们可以将参数类型改为 auto。然后，我们需要一种方法来反转输入内容，而不局限于字符串类型。幸运的是，Ranges 库提供了一个 reverse\_view，正好可以满足这一需求。最后，我们需要比较原始值和反转后的值，同时仍然保持对类型的宽松限制。C++ 标准库为我们提供了 std::equal 来完成这个任务。最终我们得到了如下代码，它不仅可以用于字符串，还可以用于表示短语的 vector<string>，或者定义在枚举中的词法单元（tokens）。

让我们见识一下极端多态的实际效果：

\begin{cpp}
bool isPalindrome(auto value){
  auto tokens = value | std::views::all;
  auto reversedTokens = value | std::views::reverse;
  return std::equal(tokens.begin(), tokens.end(), reversedTokens.begin());
};

enum Token{
  X, Y
};

TEST_CASE("Extreme polymorphic palindrome"){
  CHECK(isPalindrome(string("asddsa")));
  CHECK(isPalindrome(vector<string>{"asd", "dsa", "dsa", "asd"}));
  CHECK(isPalindrome(vector<Token>{Token::X, Token::Y, Token::Y, Token::X}));
}
\end{cpp}

也许我现在已经向你展示了为什么我觉得这种编程风格非常吸引人。如果我们忽略类型，或者让我们的函数具备极高的多态性，我们就能写出适用于未来各种情况的代码，而无需频繁修改。但这种做法也有其权衡：代码的约束条件现在隐藏在被推导出的类型中，而且参数与函数的命名变得非常重要。例如，如果我传入一个整数给 isPalindrome 函数，我不会得到一个简单的错误提示（告诉你参数类型不正确），而是会遇到一个复杂的编译错误。

以下是在我的电脑上使用 g++ 编译器尝试传入整数时，所产生的错误信息开头部分：

\begin{shell}
In file included from testPalindrome.cpp:3:
Palindrome.h: In instantiation of 'bool isPalindrome(auto:21)
[with auto:21 = int]':
testPalindrome.cpp:30:2: required from here
Palindrome.h:14:29: error: no match for 'operator|' (operand types are 'int' and 'const std::ranges::views::_All')
14 | auto tokens = value | std::views::all;
   | ~~~~~~^~~~~~~~~~~~~~~~~
\end{shell}

现在由您决定：您更喜欢强类型还是极端多态行为？两者都有其权衡和自己的应用领域。



















