

软件开发中最大的挑战之一就是避免 bug。这是一个如此普遍的问题，以至于我们专门用一个词来形容它，暗示我们的代码“出事了”。然而事实上，我们应该把这些叫做错误(mistakes)，因为它们本质上就是开发者的失误。

既然我们有编译器，那为什么不能对代码施加足够的限制，让编译器在出现 bug 时告诉我们呢？我们或许可以做到这一点，只不过不是免费的(需要付出设计和实现成本)。前一节我们讨论了模板元编程，但我们忽略了一个重要的特性：模板元编程是图灵完备的(Turing complete)。这意味着，任何我们可以用常规方式写出的程序，也可以使用模板元编程来实现。

这个想法非常强大，并且在各种背景下被广泛讨论过。如果你想尝试一门完全围绕这一理念构建的编程语言，可以试试 Idris(\url{https://www.idris-lang.org/})。许多开发者可能熟悉 Haskell 中在编译时进行验证的支持功能。而我第一次接触这个概念，是在 Andrei Alexandrescu 于 2001 年出版的开创性著作《Modern C++ Design: Generic Programming and Design Patterns Applied》中。

让我们考虑一个简单的问题。bug 和代码异味(code smell)的一个常见来源被称为“原始类型痴迷”(primitive obsession)，也就是过度使用原始类型来表示复杂的数据。“原始类型痴迷”的典型例子是将长度、金额、温度或重量等数据表示为简单的数字，完全忽略其单位。与其这样做，不如为这些概念定义特定的类型。例如，“金额”类型可以包含一个根据上下文决定精度的值(如会计系统中常用的七位小数)以及货币种类。即使程序只处理一种货币，这种做法在软件开发中也是非常有用的。因为你几乎可以肯定一件事：当功能越来越多时，原来只支持一种货币的系统，最终很可能会变成支持多种货币——你的客户迟早会让你加上对第二种货币的支持。

与“原始类型痴迷”相关的一个典型问题是：如何对原始类型进行约束。比如，考虑一个用于存储一天中小时数的类型。这个值不仅仅是一个 unsigned int，而且必须在 0 到 23 的范围内(这里我们为了简单起见假设使用 24 小时制)。如果我们能告诉编译器：“任何不在 0-23 范围内的值都不能作为合法的小时数”，并在传入例如 27 这样的值时给出明确的错误信息，那就太好了。

在这种情况下，由于取值数量有限，使用 enum 可能是一个解决方案。但我们现在先忽略这个选项，首先考虑在运行时如何实现这一目标。我们可以设想一个名为 Hour 的类，在构造函数中如果传入的值不在 0 到 23 之间就抛出异常：

\begin{cpp}
class Hour{
private:
  int theValue = 0;
  void setValue(int candidateValue) {
    if(candidateValue >= 0 && candidateValue <= 23){
      theValue = candidateValue;
    }
    else{
      throw std::out_of_range("Value out of range");
    } 
  }

public:
  Hour(int theValue){
    setValue(theValue);
  }

  int value() const {
    return theValue;
  }
};

TEST_CASE("Valid hour"){
  Hour hour(10);
  CHECK_EQ(10, hour.value());
}

TEST_CASE("Invalid hour"){
  CHECK_THROWS(Hour(30));
}
\end{cpp}

如果我们想在编译时移动检查怎么办?好吧,是时候使用 constexpr 的强大功能告诉编译器编译时定义了哪些值,并使用static\_assert验证范围:

\begin{cpp}
template <int Min, int Max>
class RangedInteger{
private:
  int theValue;
  constexpr RangedInteger(int theValue) : theValue(theValue) {}
public:
  template <int CandidateValue>
  static constexpr RangedInteger make() {
    static_assert(CandidateValue >= Min && CandidateValue <= Max, "Value out of range.");
    return CandidateValue;
  }

  constexpr int value() const {
    return theValue;
  }
};

using Hour = RangedInteger<0, 23>
\end{cpp}

在前面的实现中，以下代码可以完美地工作：

\begin{cpp}
TEST_CASE("Valid hour"){
  constexpr Hour h = Hour::make<10>();

  CHECK_EQ(10, h.value());
}
\end{cpp}

但是如果我们尝试传递一个超出范围的值，我们会得到一个编译错误：

\begin{shell}
TEST_CASE("Invalid hour"){
  constexpr Hour h2 = Hour::make<30>();
}
Hour.h: In instantiation of 'static constexpr RangedInteger<Min, Max>
RangedInteger<Min, Max>::make() [with int CandidateValue = 30; int Min
= 0; int Max = 23]':
Hour.h:11:87: error: static assertion failed: Value out of range.
   11 | static_assert(CandidateValue >= Min && CandidateValue <= Max, "Value out of range.");
      |                                        ~~~~~~~~~~~~~~~^~~~~~
Hour.h:11:87: note: '(30 <= 23)' evaluates to false
\end{shell}

这个错误告诉我们：不能使用数值 30 来表示小时，这正是我们所需要的！

这只是一个工具箱中的技巧，适用于那些希望编写出在编译时就能被证明是合法有效的 C++ 程序的开发者。正如我们前面提到的，模板元编程是图灵完备的，这意味着理论上我们可以将任何在运行时能实现的程序，也通过编译时的方式来实现。当然，这其中也存在权衡。请注意，这里的 Hour 值必须是 constexpr 的，这意味着该值会被存储在可执行文件中。这是有意为之的，因为要将类型约束发挥到极致，唯一的方法就是将其直接编译进程序单元中。

在实践中，我发现这种技术很容易导致代码变得极其难以理解和修改。对这类代码进行修改需要极强的纪律性，因为哪怕是对现有代码的一点改动，都可能引入新的 bug——而这些 bug 本来是可以通过强类型机制避免的。基本的原则始终是：多用添加的方式扩展功能，少去修改已有代码，除非是为了修复问题。我们目前还能保持代码干净，但类型很快就会变得非常抽象，使得六个月后再回头看当初的设计思路时，几乎很难还原其背后的逻辑。从积极的一面来看，这种技术最适合用于开发专注于特定领域的类库(libraries)。

虽然我认为这种技术非常有趣，但在实际编程中我更倾向于拥有更多的自由度。我会采用自己的一套方法：测试驱动开发(TDD)、持续重构、命名上的极致关注以及简单设计。我更希望有一种方式，让我写出我想写的代码，并让编译器去处理细节问题。

正因为如此，我接下来要讨论的最后一种编程范式，会尽可能地忽略类型的影响。