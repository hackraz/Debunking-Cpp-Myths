
我还记得在大学的时候，对编程充满了热情，已经相当熟练地掌握了 BASIC、Pascal、Logo，以及简单的 C++。我想是在大二时，我选修了一门关于函数式编程的课程。老师非常热情，也急于向我们展示这种编程范式的奇妙之处，讲解了许多我当时难以理解的概念。对我来说，这门课最终完全没能达到效果，因为我唯一学到的，是如何在 Lisp 中编写命令式代码，以及如何把我熟悉的那些编程习惯翻译成这种“怪异”的语言——它把括号穿在表达式的外面。

我成为软件工程师后，尝试重新接触函数式编程。网上有很多资源，但它们解释这一范式的方式并没有帮助到我。“它基本上就是范畴论”，他们说。一切皆为函数，甚至数字也是(可以看看 Church 编码)。你可以轻松理解单子(Monad)，因为它们是自函子范畴中的一个幺半群。这种解释方式使用了更复杂的概念来解释实际的概念，并不利于理解。

这就是为什么我花了好几年时间才理解函数式编程是什么，以及它如何有助于软件开发。我成为了这一范式的粉丝，但不是狂热者。像任何工程师一样，我喜欢解决问题，在我的案例中，最常通过编写代码来解决。拥有更简单的代码总是很棒的，尽管简单并不总是意味着熟悉。

如果今天要我解释函数式编程，我会专注于三个重要的方面：不可变性、纯函数和函数操作。或许出乎意料的是，C++ 非常适合这些特性。在不可变性方面，C++ 相较于其他主流编程语言表现突出(虽然不如 Rust，但关于这一点我们将在最后一章讨论)。

然而，有一个需要注意的地方：函数式编程是一种不同的范式，有自己的权衡。我注意到 C++ 开发者发现很难思考 lambda 表达式，因为他们不把 lambdas 视为基础概念，而是看作构建在现有语言之上的东西。这完全可以理解，因为在 C++ 中，lambdas 是对象而不是第一类设计元素。然而，采用函数式思维要求开发者暂时忘掉这些知识，接受函数式设计元素。当你已经实现了一个可行的东西并寻找改进时，可以再回到这些知识。

接下来，让我们更详细地解释这三个特性，然后讨论函数式编程对我们软件架构的影响。 

\begin{itemize}
\item 
不可变性：指的是数据一旦创建就不能被改变。在 C++ 中，可以通过 const 关键字来实现一定程度的不可变性。

\item 
纯函数：指的是函数的输出仅由输入决定，且没有副作用。这意味着函数不会修改外部状态或进行 I/O 操作等。

\item 
函数操作：包括高阶函数的使用，如将函数作为参数传递或返回，以及组合函数等操作。C++ 支持诸如 std::function 和 lambda 表达式等功能，使得这类操作变得可能。 
\end{itemize}

采用这些原则可以帮助我们构建更加模块化、可测试和可靠的系统。

\mySubsubsection{3.3.1}{不变性}

不可变性从根本上意味着每个变量都会被初始化为一个值，但之后不能再为该变量赋新的值。在 C++ 中，这可以通过 const 或 constexpr 来实现，具体取决于我们希望该值是在运行时还是编译时保持不可变。

对于简单类型来说，不可变性很容易理解，但在处理集合(collections)和对象时则带来了挑战。一个不可变的集合是指每次修改后都会返回一个新集合的对象。例如，下面的代码展示的是一个可变集合：

\begin{cpp}
vector<int> numbers {1, 2, 3};
numbers.push_back(4);
assert(numbers == vector<int> {1, 2, 3, 4});
\end{cpp}

将此示例与下一个代码示例中所示的假设不可变集合进行对比,该集合在添加到该集合时回一个新集合:

\begin{cpp}
immutable_vector<int> numbers {1, 2, 3};
immutable_vector<int> moreNumbers = numbers.push_back(4);
assert(numbers == immutable_vector<int> {1, 2, 3});
assert(moreNumbers == immutable_vector<int> {1, 2, 3, 4});
\end{cpp}

这一特性可以保证你始终使用的是所需数据结构的正确版本。但你的 C++ 头脑中可能已经响起了内存优化的警钟。对于不可变集合来说，看起来似乎发生了大量的内存分配！这不会是一种浪费吗？

在对不可变集合进行修改时，确实可能会暂时使用比预期更多的内存。然而，函数式语言已经找到了聪明的方式来避免这个问题，而 C++ 完全有能力采用相同的机制，这取决于具体的实现方式。

要优化不可变集合的内存使用，方法是使用智能指针。请记住，值一旦赋给变量就不可更改。因此，当集合第一次被初始化时，会为集合中的每个元素分配内存，并且每块内存区域都对应一个特定的值。当添加新元素时，所有指向现有元素的指针都会被复制，并为新值分配一块新的内存区域。如果从集合中删除一个元素，则除了指向被删除元素的指针之外，其余所有指针都会被复制。一旦某块内存区域不再被任何指针引用，它就会被自动删除。

虽然 STL 中并没有直接提供这种不可变集合的实现，但像 immer 这样的库(\url{https://github.com/arximboldi/immer})可以让你轻松使用这种模式，而不必过多关注其内部细节。

好，那不可变对象呢？难道面向对象编程(OOP)的目的不就是将行为与数据结合在一起吗？对此，我有三点要说：

第一，问得好！

第二，人们误解了 OOP 的本质，认为它关乎封装、继承和多态；实际上，OOP 的核心在于消息传递。不幸的是，C++ 成为了我称之为“类导向编程”(class-oriented programming)的先驱：一种专注于类及其关系，而不是对象及其关系的编程风格。

第三，函数式编程其实并不排斥对象。实现不可变对象非常简单：要么我们使用 const 来实现不可变的数据结构，要么每一个用于修改数据的方法都返回一个带有修改后数据的新对象。

需要指出的是，你并不一定要在程序中将不可变性发挥到极致，才能从函数式编程中受益。我自己写的很多代码中也尽量最大化使用 `const`，但仍然使用标准 STL 的集合和会修改自身内部数据的对象。

然而，你需要意识到，前面所描述的不可变性程度可以让你更容易地在程序中引入并行性(parallelism)。如果值是不可变的，你就无需担心临界区的问题。每个线程操作自己的值，修改值也只是针对特定线程生效。事实上，这是不可变性带来的一个额外好处。我称之为“额外”好处，是因为不可变性与纯函数以及良好的命名结合之后，能让你的程序在你熟悉这些构建模块之后变得更加易于理解。接下来，让我们来看看什么是纯函数。

\mySubsubsection{3.3.2}{纯函数}

纯函数(Pure Function)是指对于相同的输入总是返回相同的输出，并且不会改变其上下文中的任何值。根据定义，纯函数不能执行输入/输出(I/O)操作。然而，任何非平凡的程序都可以被写成纯函数与 I/O 函数的组合。

纯函数是你能想到的最简单的函数类型。它们易于理解、高度可预测，并且可以缓存，因为它们没有副作用。这使得通过数据驱动的单元测试变得非常容易，并且还可能带来一些优化机会，例如在第一次以特定输入调用函数时缓存其结果，并在之后重复使用该结果。

纯函数是函数式编程的核心。在 C++ 中，借助对不可变性的支持，实现纯函数非常简单。

在纯函数式语言中，函数最初的写法是使用 lambda 表达式。自 C++11 起，lambda 也进入了标准。然而，C++ 的 lambda 表达式可以是可变的，因为它们可以修改所捕获的上下文中的变量。因此，在 C++ 中编写纯函数——即使使用 lambda 表达式——也需要你确保所有涉及变量的 const 正确性。

在函数式范式中，一切要么是函数，要么是数据结构，而在纯函数式语言中，这两者是可以互换的。那么，我们如何从简单函数构建出复杂的行为呢？当然是通过各种操作将函数组合(compose)在一起。

\mySubsubsection{3.3.3}{函数操作}


既然函数是函数式编程中的主要设计元素，那么思考函数如何通过各种操作进行变换，也就成了顺理成章的事情。最常见的函数式操作包括部分应用(partial application)和组合(composition)。

部分应用是指通过将一个函数的某个参数绑定到一个特定值上，从而创建出一个新的函数。例如，如果我们有一个函数 add(const int first, const int second)，我们可以通过将第二个参数绑定为值 1，来获得一个新的 increment(const int) 函数。

让我们花一点时间思考一下这个做法的含义：每一个函数，无论它接收多少个参数，都可以通过连续的部分应用被逐步简化为一个不接收任何参数的函数。这为我们提供了一种通用的语言，用来表达代码中的任何逻辑。

在 C++ 中实现部分应用，我们可以使用 <functional> 头文件中的 std::bind 函数。下面我们来看看如何通过将 add 函数的第二个参数绑定为 1 来获得 increment 函数：

\begin{cpp}
#include <functional>
auto add = [](const int first, const int second){ return first +
second; };
auto increment = std::bind(add, std::placeholders::_1, 1);
TEST_CASE("add"){
  CHECK_EQ(10, add(4, 6));
}
TEST_CASE("increment"){
  CHECK_EQ(10, increment(9));
}
\end{cpp}

从函数式编程的角度来看，这是一个简洁有效的解决方案。然而，它的返回值类型较为复杂，并不是真正意义上的函数，而只是近似于函数的对象。这是 C++ 开发者在尝试函数式编程时面临的一个心理障碍。我自己已经离开这门语言一段时间了，正好足以让我从更高层次的概念去思考问题，而不是总去分析底层实现。因此，当我使用 std::bind 进行部分应用时，我会将结果当作一个函数来看待，并相信实现者已经完成了优化和行为正确性的保障工作。

函数的另一个基本操作是函数组合(functional composition)。你可能在数学中接触过这种结构。函数组合指的是，从两个函数 g 和 h 构造出一个新的函数 f，使得对任意输入 x，都有 f(x) = g(h(x))。在数学中，这通常表示为 f = g ∘ h。

不幸的是，C++ 标准中并没有直接提供用于函数组合的操作或函数，但使用模板很容易自行实现这一功能。再次说明，这个操作在 C++ 中的结果类型也很复杂，但我鼓励你把它当作一个函数来看，而不是纠结于其实际的数据结构。

让我们看看一个可能的 C++ 函数组合实现：compose 函数接受两个类型参数 F 和 G，分别代表要组合的两个函数类型 f 和 g。compose 函数返回一个 lambda 表达式，该表达式接受一个参数 value，并返回 f(g(value))：

\begin{cpp}
template <class F, class G>
auto compose(F f, G g){
return [=](auto value){return f(g(value));};
}
\end{cpp}

\begin{myTip}{}
前面的示例借用自 Alex 与 Packt Publishing 合作的另一本关于该主题的书 《Hands-On Functional Programming in C++》。
\end{myTip}

让我们通过一个简单的例子来看看如何使用这个函数。我们来实现一个价格计算器，它接受价格、折扣、服务费和税率为参数，并返回最终价格。我们先来看一个命令式的实现方式：使用一个函数，在函数内部直接计算所有步骤。computePriceImperative 函数接收价格，减去折扣，加上服务费，然后在基础上加上税率：

\begin{cpp}
double computePriceImperative(const int taxPercentage, const int
serviceFee, const double price, const int discount){
  return (price - discount + serviceFee) * (1 + (static_cast<double>(taxPercentage) / 100));
}
TEST_CASE("compute price imperative"){
  int taxPercentage = 18;
  int serviceFee = 10;
  double price = 100;
  int discount = 10;
  double result =
  computePriceImperative(taxPercentage, serviceFee, price, discount);
  CHECK_EQ(118, result);
}
\end{cpp}

这是一个简单的实现，足以给出正确的计算结果。然而，这种类型的代码通常在我们需要添加更多种类的折扣、根据商品类型修改税率，或者改变折扣应用顺序时开始变得复杂。当然，在适当的时候我们可以采用命令式或面向对象的方式，将每个操作提取成单独的函数，然后按需组合这些函数。

但现在我们来看看函数式风格的实现。我们可以做的第一件事是为每一个操作使用 lambda 表达式，并用另一个 lambda 来完成最终的计算。我们实现几个 lambda 函数：一个用于从价格中减去折扣，一个用于加上服务费，一个用于加上税，最后一个则通过依次调用前面定义的所有 lambda 来计算最终价格。最终得到如下代码：

\begin{cpp}
auto discountPrice = [](const double price, const int discount){return
price - discount;};
auto addServiceFee = [](const double price, const int serviceFee){
return price + serviceFee; };
auto applyTax = [](const double price, const int taxPercentage){
return price * (1 + static_cast<double>(taxPercentage)/100); };
auto computePriceLambda = [](const int taxPercentage, const int
serviceFee, const double price, const int discount){
  return applyTax(addServiceFee(discountPrice(price, discount),serviceFee), taxPercentage);
};

TEST_CASE("compute price with lambda"){
  int taxPercentage = 18;
  int serviceFee = 10;
  double price = 100;
  int discount = 10;
  double result = computePriceLambda(taxPercentage, serviceFee, price,
  discount);
  CHECK_EQ(118, result);
}
\end{cpp}

这段代码更好吗？嗯，这取决于具体情况。其中一个因素是你对这种编程范式的熟悉程度，但不要让不熟悉成为阻碍——正如我之前所说，熟悉感常常与简单性混淆，但二者并不相同。另一个因素是：要把这些 lambda 表达式看作函数，而不是数据结构。一旦你克服了这两个心理障碍，就会注意到一些事情：这些 lambda 非常小巧、易于理解，并且它们是纯函数——客观来说，这是最简单的函数形式。我们可以以多种方式链式调用它们，例如，将折扣应用在含税价格上，因此这种实现方式给了我们更多的灵活性。到目前为止，这些功能在命令式编程中其实也并非无法实现。

那我们再迈出下一步，让这个实现真正“函数式”起来。我们将使用之前创建的 lambda 表达式，但不同于直接返回一个值，我们的实现将使用部分应用和函数组合，来返回一个能够给出最终答案的函数。由于前面定义的 lambda 都有两个参数，我们在进行函数组合之前，需要先将其中一个参数通过绑定的方式固定下来。具体来说：对于 discountPrice 这个 lambda，我们将它的 discount 参数绑定为传入 computePriceFunctional 函数的值，从而得到一个只接受一个参数(初始价格)并返回打折后价格的新 lambda；对于 addServiceFee lambda，我们将 serviceFee 参数绑定为传入的值，得到一个只接受一个参数(服务费前的价格)并返回加上服务费后价格的函数；对于 applyTax lambda，我们将 taxPercentage 参数绑定为传入的值，得到一个只接受一个参数(不含税的价格)并返回含税价格的函数。当我们得到了这些只接受一个参数的函数之后，就可以使用之前展示过的 compose 函数将它们组合在一起，最终得到一个只接受一个参数 price 的函数，当被调用时，它会计算出正确的最终价格。

下面是最终的实现结果：

\begin{cpp}
auto computePriceFunctional(const int taxPercentage, const int
serviceFee, const double price, const int discount){
  using std::bind;
  using std::placeholders::_1;
  auto discountLambda = bind(discountPrice, _1, discount);
  auto serviceFeeLambda = bind(addServiceFee, _1, serviceFee);
  auto applyTaxLambda = bind(applyTax, _1, taxPercentage);
  return compose( applyTaxLambda, compose(serviceFeeLambda,
  discountLambda));
}

TEST_CASE("compute price functional"){
  int taxPercentage = 18;
  int serviceFee = 10;
  double price = 100;
  int discount = 10;
  auto computePriceLambda = computePriceFunctional(taxPercentage,
  serviceFee, price, discount);
  double result = computePriceLambda(price);
  CHECK_EQ(118, result);
}
\end{cpp}

这种编程风格乍一看与面向对象编程(OOP)或结构化编程所使用的风格截然不同。但如果你稍加思考，就会意识到：一个对象本质上只不过是一组内聚的、部分应用的函数。如果你将这些函数从对象中提取出来，就需要显式传入原本在对象中使用的数据成员——这种风格对于那些曾经用 C 语言编写过程序的人来说非常熟悉。

因此，将一个方法包含在对象中，其实就等价于将一些参数绑定到由构造函数初始化的对象数据成员上。由此可见，OOP 和函数式编程并非真正的对立面，而只是表达相同行为的两种不同且等价的方式，各有其权衡取舍。

作为对后续“元编程”章节的铺垫，我们来看看如何让所有这些函数在编译时就可用。我们需要借助一点模板的魔法，将值参数作为模板参数传入，并添加大量 constexpr。不过，下面的代码同样可以很好地工作：

\begin{cpp}
template <class F, class G>
constexpr auto compose(F f, G g){
  return [=](auto value){return f(g(value));};
}

constexpr auto discountPriceCompile = 
[](const double price, const
int discount){return price - discount;
};

constexpr auto addServiceFeeCompile = 
[](const double price, const
int serviceFee){ 
  return price + serviceFee; 
};

constexpr auto applyTaxCompile = 
[](const double price,
cons t int taxPercentage){ 
  return price * (1 + static_cast<double >(taxPercentage)/100); 
};

template<int taxPercentage, int serviceFee, double price, in t
discount>
constexpr auto computePriceFunctionalCompile() {
  using std::bind;
  using std::placeholders::_1;
  constexpr auto discountLambda = bind(discountPrice, _1, discount);
  constexpr auto serviceFeeLambda = bind(addServiceFee , _1, serviceFee);
  constexpr auto applyTaxLambda = bind(applyTax, _1, taxPercentage);
  return compose( applyTaxLambda, compose(serviceFeeLambda, discountLambda));
}

TEST_CASE("compute price functional compile"){
  constexpr int taxPercentage = 18;
  constexpr int serviceFee = 10;
  constexpr double price = 100;
  constexpr int discount = 10;
  constexpr auto computePriceLambda =
  computePriceFunctionalCompile<taxPercentage, serviceFee, price,
  discount>();
  double result = computePriceLambda(price);
  CHECK_EQ(118, result);
}
\end{cpp}

至此，我们已经看到了 C++ 中函数式编程的基本块。现在让我们看看它们在哪些方面有用
以及为什么有用。

\mySubsubsection{3.3.4}{函数式风格的架构模式}

让我们首先来看看如何将一个应用程序完全按照函数式风格来实现。我们无法讨论这种应用程序的所有可能的设计模式，但可以展示一些示例。

我们首先注意到，函数式编程对我们设计施加了一些约束：

\begin{itemize}
\item 
我们倾向于使用不可变性和纯函数；

\item 
我们使用数据结构，但它们是不可变的，这意味着每次对数据结构的修改都会生成一个新的版本；

\item 
元编程

\item 
最后，I/O 部分需要独立出来，并尽可能薄，因为 I/O 操作通常涉及状态变更。
一种使用这些约束的简单设计模式是管道(pipe)模式。
\end{itemize}

假设我们接收到一个 XML 格式的文件，并需要从中提取数据调用 Web 服务。我们可以构建一个输入层来读取 XML 文件，一个输出层来向 Web 服务写入数据，而中间层则采用函数式风格进行处理。接下来，我们可以分析输入与输出的数据，并在输入上逐步实施一系列转换操作，最终得到所需的输出。每一步转换都是一个作用于不可变数据结构上的纯函数。

由于没有状态变更，这样的流程具有高度的可并行化特性。事实上，C++17 引入了 <execution> 头文件，允许以并行方式运行常见的 STL 算法。类似的设计模式也广泛应用于数据转换架构中，例如“抽取、转换、加载”(Extract, Transform, Load，简称 ETL)架构，以及由 Hadoop 推广开来的 MapReduce 架构。

这种模式不仅可以用于数据转换场景，还可以扩展为更通用的“函数式核心 + 命令式外壳”(functional core, imperative shell)架构，这个名称由 Gary Bernhardt 提出，非常贴切。如果你希望了解更多细节，可以研究带有函数式核心的六边形架构(hexagonal architecture)。

这表明我们不仅可以在 C++ 中使用函数式范式来设计程序，而且在某些场景下这种架构是非常合适的。它还说明我们可以采用这种编程风格的一部分，并将其应用到我们实现中的某些模块中。


























