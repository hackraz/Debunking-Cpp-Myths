
当 Linux 加载并执行一个应用程序时（比如我们想要执行一个应用程序，而不是 shell 脚本或其他东西），通常会启动一对 fork（）/execve（） 系统调用来开始执行应用程序。

这些系统调用负责复制当前进程（fork()）并将当前进程的映像替换为一个新的进程映像（即要执行的应用程序——execve()）。

这些 API 调用在 Mark Mitchell、Jeffrey Aldham 和 Alex Samuel 所著的《Advanced Linux Programming》一书中有着非常详细的介绍。此外，网上也有大量关于这一主题的资源。因此，如果你对这个主题感兴趣，可以在这些资料中找到良好的信息来源。

但让我们继续探讨可执行文件的加载过程。execve() 系统调用在多次调用后会脱离用户空间的限制，最终进入 Linux 内核，并创建一个 linux\_binprm 结构体\footnote{\url{https://github.com/torvalds/linux/blob/master/include/linux/binfmts.h}}。

根据文档说明，该结构体在加载二进制文件时使用，其中包含了加载和执行一个二进制文件所需的所有主要信息。

如果你有很多空闲时间，手边还有一大杯茶，并且对 C 语言的复杂机制有深入了解，你可以尝试阅读 Linux 内核源码树中 do\_execveat\_common 函数的冗长实现，以了解更多关于该函数幕后工作的细节\footnote{\url{https://github.com/torvalds/linux/blob/master/fs/exec.c}}。

接着，内核会判断可执行文件的格式。在 Linux 系统中，最常见的可执行文件格式是 ELF（可执行与可链接格式）。

所有字段都在官方标准文档中有详细描述\footnote{\url{https://refspecs.linuxfoundation.org/elf/elf.pdf}}，在此我们仅对我们当前使用场景相关的字段做一个简要总结：

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}{|p{2cm}|p{1cm}|p{10cm}|}
\hline
\textbf{字段名} & \textbf{偏移} & \textbf{描述}                                       \\ \hline
\endfirsthead
%
\multicolumn{3}{c}%
{{\bfseries 延续上一页的图表}} \\
\endhead
%
MAGIC    & 0x00 & 表示文件是ELF文件的魔数（“ELF”在ASCII和0x7F中表示）      \\ \hline
CLASS               & 0x04            & ELF文件的类（32位或64位）     \\ \hline
e\_type  & 0x10 & 标识目标文件类型（例如，可执行文件、共享对象，等等）   \\ \hline
e\_machine          & 0x12            & 指定为其编译文件的架构 \\ \hline
e\_entry & 0x18 & 虚拟地址，系统首先将控制权转移到该地址，然后开始进程 \\ \hline
\end{longtable}

请记住这张表格，因为我们稍后会再次引用它。但现在，让我们继续探讨程序的加载过程。现在该轮到内核读取 ELF 头部，以了解可执行文件的结构。

在这一阶段，会发生以下操作：

\begin{itemize}
\item 
内存分配：内核为新进程分配内存。这包括设置进程的地址空间，地址空间由不同的段（segment）组成，例如文本段（代码）、数据段、堆（heap）和栈（stack）。

\item 
节区映射：内核将可执行文件中的各个节区映射到进程的地址空间中。例如，文本段（包含可执行代码）被映射为只读，而数据段（包含全局变量）被映射为可读写。

\item 
动态链接：如果该可执行文件依赖共享库（shared libraries），则会调用动态链接器/加载器（ld.so）来加载必要的共享库并解析符号引用。动态链接器还会将这些库映射到进程的地址空间中。
\end{itemize}

这些操作都发生在 Linux 内核的深处。如果你对这个领域感兴趣，我们鼓励你去阅读源代码——也许你会发现一些有趣的内容。

一旦这些有趣且非常底层的操作成功完成，内核就会为该进程设置初始的环境栈（stack）。该栈中包含以下内容：

\begin{itemize}
\item 
参数向量（argv）：命令行参数的数组

\item 
环境变量（envp）：环境变量的数组

\item 
辅助向量（auxv）：程序所需的附加信息，例如系统页面大小、程序入口点等
\end{itemize}

所有这一切都发生在之前提到的同一个内核源文件（binfmt\_elf.c）中的如下函数里：

\begin{cpp}
static int create_elf_tables(struct linux_binprm *bprm,
const struct elfhdr *exec, unsigned long interp_load_addr,
unsigned long e_entry,unsigned long phdr_addr) { ... }
\end{cpp}

在创建运行时环境后，内核会设置指令指针（IP），使其指向程序的入口点（在 ELF 头中指定）。CPU 寄存器也会按照要求进行初始化。最后，内核将 CPU 切换回用户模式，并将控制权转移到程序的入口点。

在 Linux 中，控制权的转移主要发生在 start\_thread() 函数中，该函数与架构相关。在撰写本文时，对于 x86 架构，该函数定义在 arch/x86/include/asm/processor.h 中，并在 arch/x86/kernel/process\_64.c 中实现。程序从此处开始执行。现在就到了最有趣的部分——至少从 C++ 开发者的角度来看是如此。

首先，程序的初始化代码（通常是 C 运行时库的一部分）会被执行——通常是 \_start() 函数，而不是 main()。ELF 头中的 e\_entry 字段列出了程序开始执行时在文件中的偏移量。通常，它指向 \_start() 函数的偏移地址，至少在使用标准 GNU 工具链编译可执行文件的情况下是如此。

这段代码负责设置运行时环境，并调用程序的 main() 函数。从这一点开始，程序便按照我们所编写的指令运行。

那么，让我们来看看这个初始化代码到底是什么。我们将使用一个得心应手的工具 Ghidra，它可以用来剖析 Linux 可执行文件并研究其内部机制。该工具为我们这个几乎为空的应用程序提供了以下概览：

\myGraphic{0.9}{content/chapter4/images/1.png}{图 4.1 – 我们合成应用程序的结构}

在查看 ELF 源文件部分时，我们可以看到我们最初的 main.cpp 文件；但除此之外还有一些我们还不熟悉的文件，例如 crtstuff.c。该文件属于 libgcc，可以在 libgcc 的代码仓库\footnote{\url{https://github.com/gcc-mirror/gcc/blob/master/libgcc/crtstuff.c}}中找到，在文件顶部写着如下注释：

\begin{cpp}
/* Specialized bits of code needed to support construction and destruction of file-scope objects in C++ code.
\end{cpp}

至此，其中一个谜团已经解开，而注释本身也已不言自明。然而，还有一个问题仍然存在：Scrt1.o 是什么？要理解这一点，我们需要了解“固定地址可执行文件”（fixed-address executables）和“位置无关可执行文件”（Position-Independent Executables，简称 PIE）之间的区别。

固定地址可执行文件是被编译为在特定、预定义的内存地址加载的程序。它们结构简单，但安全性与灵活性较差，因为其内存地址是可预测的，容易受到攻击。这种方式常见于嵌入式设备以及一些旧平台（例如 MS-DOS，它也要求 .com 应用程序必须从特定偏移地址加载）。

位置无关可执行文件（PIE），则被编译和链接为可以在任意内存地址加载的程序。这大大提高了程序的安全性，因为它支持 ASLR（地址空间布局随机化）——一种安全机制，通过随机化程序加载的内存地址，使得攻击者难以预测关键代码的位置。

当你编译一个程序时，你可以使用各种标志来控制编译器生成代码的方式。其中 -fPIE、-pie 和 -fPIC 这些标志就与代码在内存中的定位和处理方式有关。下面是对每个标志的简要说明：

\begin{itemize}
\item 
-fPIE（position-independent executable）：

该标志告诉编译器生成适用于可执行文件的位置无关代码。这对于创建支持 ASLR 的可执行文件非常有用。

\item 
-pie（链接阶段使用的 PIE 标志）：

该标志用于链接阶段，指示链接器生成一个位置无关的可执行文件。这意味着最终输出的可执行文件可以加载到内存中的任何地址，从而支持 ASLR。它通常与 -fPIE 配合使用，确保整个可执行文件都是位置无关的。

\item 
-fPIC（position-independent code）：

该标志用于生成共享库的位置无关代码。共享库需要能够在不同程序中被加载到不同的内存地址，因此这种特性对共享库至关重要。
\end{itemize}

现在我们已经了解了这些重要概念，让我们回到最初的问题：我们二进制文件中的另一个未解之谜 —— Scrt1.o。你还记得 \_start() 函数吗？既然你没有自己编写它，那它一定是来自某个地方。对于我们这个例子来说，它正是来自这个神奇的 Scrt1.o 文件。crtX.o 系列文件有多个变种，有的以 S 开头，有的没有。对于我们而言，Scrt1.o 的存在表明我们的应用程序是一个 PIE 可执行文件。以下是一些可能链接到我们程序中的 CRT（C RunTime）相关文件及其作用：

\begin{itemize}
\item 
crt0.o, crt1.o 等：

这些文件包含 \_start 符号，它是程序启动的关键入口点。不同 libc 实现之间命名约定可能会有所不同。

\item 
crti.o：

它为 .init 和 .fini 段定义函数前序（prologue），并触发链接器生成的动态标签（如 DT\_INIT 和 DT\_FINI）。我们稍后会详细讨论这些概念，所以目前遇到陌生术语不必担心。

\item 
Scrt1.o, gcrt1.o, Mcrt1.o：

这些是 crt1.o 的变种，用于不同场景，比如生成 PIE 或包含性能分析信息。

\item 
crtbegin.o, crtbeginS.o, crtbeginT.o：

这些文件由 GCC 使用，用于定位构造函数（constructors）。其中 crtbeginS.o 用于共享对象/PIE，crtbeginT.o 用于静态可执行文件。

\item 
crtend.o, crtendS.o：

类似于 crtbegin.o，它们用于定位析构函数（destructors），其中 crtendS.o 用于共享对象/PIE。
\end{itemize}

在我们揭开可执行文件内容的神秘面纱之后，还需要理解另一个关键部分：

ELF 文件中的 .init\_array 节区用于存储一组函数指针，这些函数会在程序启动时由操作系统的运行时加载器自动调用。

这些函数通常被称为“初始化函数”（init functions 或 initialization functions），它们会在 main() 函数之前被调用，负责初始化全局数据。

对于我们这个合成应用来说，当 Ghidra 分析完 .init\_array 节区后，它的样子如下所示：

\myGraphic{0.9}{content/chapter4/images/2.png}{图 4.2 – 用于全局变量的 .init\_array 节区}

如我们所见，这里有两个函数——一个空函数（dummy）和一个名为 \verb|_GLOBAL__sub_I_my_string| 的函数。这是一个颇有趣的名字选择。接下来，让我们利用该工具将汇编代码转换为类 C 代码的功能，来看看它具体做了什么：

\myGraphic{0.9}{content/chapter4/images/3.png}{图4.3 -如何根据Ghidra创建全局对象}

有趣，不是吗？这正是你在全局命名空间中所期望发生的行为。

在这里，my\_a 和 my\_other\_a 这两个对象被创建，它们的构造函数被调用，并且类 A 的析构函数也被注册到了 \_\_cxa\_atexit 中。尽管这一切看起来理所当然，但幕后构造函数的调用机制却颇为耐人寻味。

从这段令人有些晕头转向的反汇编代码中，你可能会感觉到构造函数似乎接收了一个“隐形”的参数，用于指定它正在构造的对象。这是正确的：这就是 this 指针，它会被隐式地添加到类的所有方法中，而无需显式声明。这也正是我们能够访问对象本身的原因。

顾名思义，\_\_cxa\_atexit 函数的作用与 atexit 类似。不过你不需要担心它，因为它不是一个应该在库之外处理的函数。

现在我们已经明白了这里发生了什么，是时候回到之前提到的另一个话题了：臭名昭著的 \_start() 函数。

如前所述，这个函数应该执行一些初始化工作，并最终调用我们的 main 函数。

根据 Ghidra 的分析，该函数确实可以在 ELF 头部中找到。根据 ELF 规范，它位于 ELF 条目列表中的 e\_entry 字段所指向的位置：

\myGraphic{0.9}{content/chapter4/images/4.png}{图4.4 -根据Ghidra的ELF头}

现在，在应用了一些拆卸魔法之后，由Ghidra提供，它看起来是这样的：

\myGraphic{0.9}{content/chapter4/images/5.png}{图4.5 - \_start例程函数，反汇编并转换为C伪代码}

这个看起来吓人的 \verb|__libc_start_main| 函数其实并没有它表面看起来那么可怕。它负责加载我们的 main() 函数，并处理操作系统所提供的参数。这个函数是 glibc 的一部分，和其他行为良好的开源软件一样，它也可以免费获取\footnote{git clone git://sourceware.org/git/glibc.git}，方便我们研究其内部机制。

在这个阶段，随着 \verb|__libc_start_main| 的执行完成，我们终于进入了真正的 main 函数——也就是我们预期程序开始运行的地方。

这些细节为我们提供了对程序执行过程的更深层次理解，也带来了优化和调试上的新机会。掌握 ELF 文件格式，可以帮助你通过使用特定的链接器选项、理解动态链接的复杂性来优化程序性能。此外，它还能帮助你在调试过程中追踪初始化流程，识别与启动相关的问题。

\mySubsubsection{4.2.1}{哦，不，还有更多！}

既然我们已经到了这一步，正坐在我们钟爱的 Linux 机器前，那就不再浪费时间，深入探讨一下这个伟大操作系统所配备的一些编译器内部机制吧。例如，让我们深入研究 ELF 文件中的 .init\_array 节区。如前所述，它负责在 main() 函数之前启动各种初始化函数。

但在这趟穿越“泥泞沼泽”的旅程继续之前，必须发出一个警告：接下来我们要讨论的内容并不适合胆小的 C++ 程序员，甚至这些内容本身就不是标准 C++ 的一部分。请参考第 2 章有关 C++ 标准性的内容。如果你能接受这些“不神圣”的编译器扩展教义，那么请继续阅读下去。

GCC（以及Clang）有一个非常方便的扩展，用于在main（）之前执行函数。这些函数被称为构造函数，它们需要用一个特定的属性来生成：

\begin{cpp}
__attribute__((constructor)) void welcome() {
printf("constructor fun\n");
}
\end{cpp}

如果我们将这段特定的代码添加到我们的合成应用程序中，我们可以期望得到以下输出：

\begin{shell}
constructor fun
A::A : Hello string
A::A : Go away string
Hello, World, Hello string, Go away string
A::~A : Go away string
A::~A : Hello string
\end{shell}

如您所见，构造函数在全局初始化代码之前执行。如果我们打开我们最喜欢的九头黑桃的可执行文件，我们将在init\_array部分看到以下内容：

\myGraphic{0.9}{content/chapter4/images/6.png}{图 4.6 – 包含构造函数的 .init\_array 节区}

有了这些知识之后，我们现在掌握了两种可以在 C++ 应用程序中、在 main() 函数之前执行代码的方法：构造函数函数（constructor functions）和全局变量。

此时，我们已经开始触及一个危险问题的表面：“静态初始化顺序灾难”（static initialization order fiasco）。这是一个在多个场合被反复讨论过的话题。这些讨论总结指出，该问题源于不同编译单元之间静态或全局变量初始化顺序的未定义性。虽然存在多种技术可以用来解决这些问题，但我们的建议是——尽量避免使用这类初始化机制。

下面的例子说明了为什么这会导致危险的情况。在这里，我们创建了几个短文件，同样使用合成内容，试图模拟现实生活中的情况：

\filename{a.h}

\begin{cpp}
#ifndef A_H
#define A_H

class C;
extern C a_c;

#endif
\end{cpp}

\filename{b.h}

\begin{cpp}
#ifndef B_H
#define B_H

class C;
extern C b_c;

#endif
\end{cpp}

\filename{C.h}

\begin{cpp}
#ifndef C_H
#define C_H

#include <cstring>
#include <cstdio>

struct C {
  C(const char* p_c) : m_c(nullptr) {
    m_c = new char[32];
    strcpy(m_c, p_c);
    printf("C::C : %s\n", p_c);
  }

  ~C() {
    printf("C::~C : %s\n", m_c);
    delete[] m_c;
  }
private:
  char* m_c;
};

#endif
\end{cpp}

\filename{a.cpp}

\begin{cpp}
#include "C.h"

C a_c("A");
\end{cpp}

\filename{b.cpp}

\begin{cpp}
#include "C.h"

C b_c("B");
\end{cpp}

\filename{main.cpp}

\begin{cpp}
int main()
{ 
}
\end{cpp}

这不是特别复杂的代码 – 它只是一个诊断 C 类,用于打印一些调试信息和一些单独的 C++ 件,用于创建上述诊断类的对象。

通常,这些文件是用 gcc 编译的,所以让我们编译它们并执行结果文件:

\begin{shell}
> $ g++ main.cpp a.cpp b.cpp -o test
> $ ./test
C::C : A
C::C : B
C::~C : B
C::~C : A
\end{shell}

这里没有什么特别的 – 我们编译并创建了一个可执行文件，它执行了它应该做的事情：在创建和销毁特定对象时打印出来。

但是，如果我们以不同的顺序指定文件会发生什么？

\begin{shell}
> $ g++ main.cpp b.cpp a.cpp -o test
> $ ./test
C::C : B
C::C : A
C::~C : A
C::~C : B
\end{shell}

真是令人意外。现在，来自 b.cpp 的 b\_c 对象竟然在来自 a.cpp 的 a\_c 对象之前被创建。现在，试想这样一个灾难性场景：我们的程序由一些全局对象组成，而这些对象的正确初始化依赖于其他全局对象已经被提前创建。

幸运的是，在 Linux 下的编译器生态系统为我们提供了必要的工具，借助一个非常实用的扩展，让我们可以在这类问题上实现对应用程序状态的良好控制。这个扩展用于指定全局成员的初始化顺序，其语法形式为：\verb|__attribute__((init_priority(XXX)))|。

无论是 gcc 还是 clang，都支持使用 init\_priority 属性来跨编译单元控制命名空间级别对象的初始化顺序。该属性允许用户为初始化过程分配一个相对优先级，优先级数值范围为 101 到 65535（包含这两个值）。数值越小表示优先级越高，也就是说，具有较低 init\_priority 值的对象会更早被初始化。

掌握了这一知识后，让我们修改之前的合成示例文件，让它们使用这个扩展：

\filename{a.cpp}

\begin{cpp}
#include "C.h"

__attribute__((init_priority(1000))) C a_c("A");
\end{cpp}

\filename{b.cpp}

\begin{cpp}
#include "C.h"

__attribute__((init_priority(1001))) C b_c("B");
\end{cpp}

现在，无论将 a.cpp 和 b.cpp 引入编译器的顺序如何，结果都将是相同的：

\begin{shell}
> $ g++ main.cpp a.cpp b.cpp -o test
> $ ./test
C::C : A
C::C : B
C::~C : B
C::~C : A
> $ g++ main.cpp b.cpp a.cpp -o test
> $ ./test
C::C : A
C::C : B
C::~C : B
C::~C : A
\end{shell}

现在,让我们回到我们的第一个合成应用程序 – 尝试创建全局对象但在同一个翻译单元中应用程序。并且还引入了“构造函数”函数的概念。让我们看看如果我们为其中一个全对象指定初始化优先级会发生什么,以及在这种情况下的顺序是什么:

\begin{cpp}
__attribute__((init_priority(1000)))
A my_other_a(my_other_string);
\end{cpp}

令人惊讶的是，输出将如下所示：

\begin{shell}
A::A : Go away string
constructor fun
A::A : Hello string
Hello, World, Hello string, Go away string
A::~A : Hello string
A::~A : Go away string
\end{shell}

为了更深入地了解幕后机制，并理解这种情况发生的原因，我们在编译后的二进制文件上运行我们心爱的工具。结果证实了我们的发现，如以下屏幕截图所示：

\myGraphic{0.9}{content/chapter4/images/7.png}{图 4.7 – 根据gcc的.init\_array节指定初始化优先级}

输出恰好是原样的，因为 .init\_array 节获得了一个新成员，该成员将在构造函数和标准全局初始化代码之前执行。

不难猜到新函数的名称包含初始化优先级。然而,仍然让作者感到困惑的是,为什么 gcc 决继续使用 my\_string 作为变量名称的后缀。这必须是 gcc 特异性的,因为使用 clang 编译同一可执行文件会生成以下 .init\_array 部分:

\myGraphic{0.9}{content/chapter4/images/7.png}{图 4.8 – Clang的不同.init\_array节，用于相同的init优先级}

作者发现，gcc 和 clang 在处理目标文件中这一关键部分时所采取的方式存在如此差异，是一件颇为有趣的事情。然而，在进一步分析这些编译器的源代码之前，这仍将是一个谜团。

\mySubsubsection{4.2.2}{库是\sout{孕育思想}意外行为的温床}

到目前为止，我们一直是一个应用程序的“快乐父母”。现在，是时候让我们这个“爱情结晶”长大成人并“结婚”了……换句话说，为了遵循一些常识以及更高级的编程实践，我们希望将合成代码中一些非常有用的功能提取出来，封装成一个合成库，并将其命名为 synth。抱歉——我说的是 libsynth。

此外，由于本章的重点仍然是剖析 main() 之前执行的代码（1），并且我们还愉快地支持使用 GCC（和 Clang）的扩展（2），那么接下来我们就来看看，如果我们把这些元素以一种“不神圣”的方式结合在一起时，会发生什么——也就是代码与数据的“结合”。

顺便说一句,我们将使用第二个 synthetic 示例,其中 a.cpp 和 b.cpp 与上一阶段保持不变, 中包括所需的初始化顺序。我们将创建一个新的 main.cpp 文件来利用库本身,我们还将绍该库的源代码。

我们的库将由以下代码构建:

\filename{synth.cpp}

\begin{cpp}
#include "C.h"
#include <cstdio>

__attribute__((init_priority(2000))) C synth_c("synth");

__attribute__((constructor)) void welcome_library() {
  printf("welcome to the library\n");
}

void print_synth() {
  printf("print_synth: %s\n", synth_c.get());
}
\end{cpp}

\filename{synth.h}

\begin{cpp}
#ifndef SYNTH_H
#define SYNTH_H

void print_synth();

#endif
\end{cpp}

除了定义一个类型为 C（如头文件 C.h 中所定义）且初始化优先级为 2000 的全局对象 synth\_c 之外，我们还定义了一个名为 welcome\_library 的函数，并使用 \verb|__attribute__((constructor))| 标记它，确保该函数在 main() 之前运行，并打印出 “welcome to the library”。

此外，print\_synth 函数会打印一条消息，显示通过调用 synth\_c.get() 所获得的值。C.h 头文件与前几页中提到的一致——它定义了类 C 及其所有必要的方法和构造函数，用于正确创建对象。

要使用这个库，我们需要为其创建相应的底层基础设施。这包括上述两个源文件，以及一个使用该库所提供功能的应用程序。

为了保持进度一致，我们需要修改我们的主程序文件，使其使用该库的功能。但同时，我们也希望保留为此场景创建的测试源文件。

因此，我们的应用程序将包含前面提到的a.cpp和b.cpp文件，以及我们新的main.cpp文件：

\filename{main.cpp}

\begin{cpp}
#include "synth.h"
#include "C.h"

__attribute__((constructor)) void welcome_main() {
  printf("welcome to the main\n");
}

C main_c("main") ;

int main() {
  print_synth();
  return 0;
}
\end{cpp}

为了使一切正常工作，我们需要链接这些项，并把它们变成一个工作的应用程序：

\begin{shell}
> $ g++ -c -o synth.o synth.cpp
> $ ar rcs libsynth.a synth.o
> $ g++ -o main main.cpp a.cpp b.cpp -L. -lsynth
\end{shell}

如你所见，在此阶段，我们已经创建了一个静态库 libsynth.a，并将主应用程序与其链接，以正确地整合库中的所有代码。

请注意，这里并没有一个 c.cpp 文件，因为为了尽可能保持简洁，我们将类的所有实现都直接写在了头文件中。对于更大的项目来说，这不是一种最佳实践，因为类中任何一个函数的实现发生微小改动，都会导致所有包含该头文件的源文件需要重新编译。不过，在这种非常特殊的情况下，我们是可以接受这一点的。

由于我们关注的是各种构造代码的执行顺序，在运行生成的应用程序后，我们得到了以下输出：

\begin{shell}
> $ ./main
C::C : A
C::C : B
C::C : synth
welcome to the main
C::C : main
welcome to the library
print_synth: synth
C::~C : main
C::~C : synth
C::~C : B
C::~C : A
\end{shell}


为了更深入地探究这个新编译的可执行文件的内部结构，我们将使用我们钟爱的工具 Ghidra 打开它，并定位到我们最感兴趣的节区：.init\_array 节区。

经过快速查看后，我们可以发现，输出的顺序与 .init\_array 节区中函数的排列顺序是一致的：

\myGraphic{0.9}{content/chapter4/images/9.png}{图 4.9 – .init\_array节用于不同文件中的不同初始化优先级}

在这里，\verb|_GLOBAL__sub_I_welcome_main| 是负责在 main.cpp 中创建全局对象的函数——也就是那一行 C main\_c("main");。有趣的是！此时我们确信，即便是对于静态库来说，全局对象的初始化顺序机制也是正常工作的。

但我们还没有结束。接下来，让我们看看如果我们创建一个共享库（shared library）时会发生什么。这并不复杂。在清除了之前生成的文件（即 synth.o、libsynth.a 和 main）以确保我们有一个干净的环境之后，我们需要运行以下命令来创建一个共享库：

\begin{shell}
> $ g++ -fPIC -c -o synth.o synth.cpp
> $ g++ -shared -o libsynth.so synth.o
> $ g++ -pie -o main main.cpp a.cpp b.cpp -L. -lsynth
\end{shell}

现在，我们可以从本章的开头看到这些神奇的开关是多么容易实现，在这里我们创建了一个共享库和使用它的应用程序。

有了这些部分，我们可以看到Ghidra呈现应用程序概述的有趣变化：

\myGraphic{0.9}{content/chapter4/images/10.png}{图 4.10 – 作为依赖项的 synth 库，如 Ghidra 所示}

在这里,我们可以看到对刚刚创建的 libsynth.so 库的依赖关系。现在,我们可以检查一下我最感兴趣的关于可执行文件的部分 – .init\_array:

\myGraphic{0.9}{content/chapter4/images/11.png}{图 4.11 – .init\_array部分没有提到 libsynth}

我们的 synth 库中的对象和函数完全没有被引用……这并不奇怪——因为它是一个库。但至少我们仍然可以确认应用程序已经正确链接到了该库：

\begin{shell}
> $ LD_LIBRARY_PATH=. ldd ./main
    linux-vdso.so.1 (0x00007fff17387000)
    libsynth.so => ./libsynth.so (0x00007ea84ee45000)
    libstdc++.so.6 => /lib/x86_64-linux-gnu/libstdc++.so.6
\end{shell}

请注意，我们必须显式地指定 \verb|LD_LIBRARY_PATH=.|，以便系统能够找到该库（同时我们还省略了部分不必要的输出行以保持内容清晰）。

此时，我们好奇地想知道在执行该应用程序时会发生什么：

\begin{shell}
> $ LD_LIBRARY_PATH=. ./main
C::C : synth
welcome to the library
C::C : A
C::C : B
welcome to the main
C::C : main
print_synth: synth
C::~C : main
C::~C : B
C::~C : A
C::~C : synth
\end{shell}

首先，根据单一应用程序测试所设定的预期，具有指定优先级的全局对象在库中被创建。接着，库中的构造函数被调用。如果库中还存在其他未指定优先级的全局对象，它们将在这些带优先级的对象之后创建；然后才是主应用程序中带优先级的对象的创建，以及主应用程序构造函数的调用。所有这一切都发生在 main() 函数甚至还没来得及“说句话”之前。

几乎完全如我们所预期的那样。但这些构造函数扩展机制中还有一个我目前尚未找到解决办法的“黑暗角落”——如果 a.cpp 和 b.cpp 中包含以下代码，会发生什么？

\begin{cpp}
__attribute__((constructor)) void welcome_a() {
  printf("welcome to the 'a' file\n"); 
}

__attribute__((constructor)) void welcome_b() {
  printf("welcome to the 'b' file\n"); 
}
\end{cpp}

这段“不祥的”代码胡写乱画般地为我们的可执行文件又添加了两个构造函数函数，现在我们一共有了三个构造函数。

如果你想让这些构造函数的执行顺序也是可预测的，你需要使用 \verb|__attribute__((constructor(205)))| 这样的语法来明确指定它们的优先级，例如：\verb|__attribute__((constructor(205))) void welcome_b()|这将确保这些函数也按照特定顺序执行，从而避免陷入“全局构造函数调用顺序灾难”。

在库是动态加载（通过 dlopen）的情况下，其行为也正如你所预期的那样：它遵循主应用程序的执行流程。当程序执行到加载该库的那一点时，会跳转并执行库中的各种构造函数和对象初始化代码。当使用 dlclose 卸载库时，相应的析构函数（如果有）也会被调用。

\mySubsubsection{4.2.3}{名言之后}

本章探讨了在 main() 函数之前执行的代码。然而，同样值得关注的还有在 main() 函数之后执行的代码，但这个话题将在另一本书中的不同章节中展开讨论。

不过，为了满足一下你的好奇心，这里先透露一个小提示：正如存在构造函数函数（constructor functions），也存在析构函数函数（destructor functions）。它们并不等同于 C++ 中的析构函数，而更像是使用 \verb|__attribute__((destructor)))| 这种方式定义的函数。

再结合标准库中用于程序退出的常规机制，你会发现这比程序启动更加复杂、也更有趣。因为你需要考虑更多的情况，比如通过 std::atexit() 或 std::quick\_exit() 注册的函数，以及异常终止程序的情形。例如：

如果一个异常在析构函数中被抛出，或者我们调用了 std::terminate() 或 std::abort(); GCC 和 Clang 的文档对这些偏离标准的行为提供了一些有趣的“冒险”，而任何一本优秀的 C++ 书籍都会对标准的终止流程提供全面的概述，因此建议你去阅读这些资料以获得深入理解。将这两部分内容结合起来，可以为你提供关于应用程序如何启动与退出的最完整视角。

但现在，在 Packt 出版社的人因为我们严重超页数（原本约定本章为 16 页，我们现在已写到第 22 页，却只覆盖了原定主题的一半）而对我们进行严厉批评之前，我们将把注意力转向其他平台。