
在我们深入探讨应用程序在 Windows 下如何执行、以及为了到达我们的 main 函数所需经历的各个步骤之前，请注意：从 C++ 的角度来看，这与 Linux 或其他任何操作系统之间不应该存在实质性的差异。仅使用 C++ 标准的功能(在 Windows 上)应与前文所展示的功能完全一致，因此我们不会在此重复相同的信息。

然而，我们将介绍应用程序在 Windows 下为何以当前方式启动，以及有哪些技术可以直接影响这一行为——就像我们在 Linux 下所做的那样。我们还将使用 Visual Studio 编译器进行演示，因为对于 Windows 平台上的 gcc 和 clang 来说，它们的行为是相同的，因此没有必要再单独介绍它们。

由于 Windows 是一个封闭系统，要理解其进程创建机制，我们必须依赖为数不多但宝贵的资料。其中一份资源就是我在该领域找到的最佳书籍之一：

《Windows Internals, 第7版(第1部分)\footnote{\url{https://learn.microsoft.com/en-us/sysinternals/resources/
windows-internals}}》(Windows 内部机制)，作者为 Pavel Yosifovich、Alex Ionescu、Mark E. Russinovich 和 David A. Solomon。

从那本书中获得的信息，结合了来自互联网世界的各种零散资料，并经过筛选整理，以期为我们的读者提供一个对 Windows 进程创建机制的轻松入门介绍。然而，我们会回过头来引用本章 Linux 部分中提到的一些概念，因此建议您先阅读那一部分内容将更有帮助。此外，还有一个小小的观察：在 Windows 中，安全性、线程处理和用户管理方面的机制要比 Linux 更加精细，并且这一切都反映在系统对进程的处理方式上。如果你有兴趣深入了解这个领域，有几份资源可供参考，例如 James Forshaw 所著的优秀书籍《Windows Security Internals: A Deep Dive into Windows Authentication, Authorization, and Auditing》(Windows 安全内部机制：深入剖析 Windows 身份验证、授权与审计)。如果你对此感兴趣，我们推荐你阅读这本书。

让我们回到进程相关的内容。在 Windows 中，进程的创建机制由操作系统中的多个组件分阶段完成：包括 Windows 的客户端库(kernel32.dll)、Windows 执行体(Windows Executive)以及 Windows 子系统进程(csrss.exe)。由于一个简单的事实——我们无法访问这些 Windows 组件的源代码——因此我们在这一主题上的介绍只能停留在非常高层的层面。

在 Windows 中，进程是通过 CreateProcess 函数族创建的。该函数族拥有一些“亲戚”和“叔伯”(例如以不同用户身份创建进程、使用各种安全权限创建进程等)，但所有这些扩展后的变种在经过几次调用迭代后，最终都会进入 kernel32.dll 中的 CreateProcessInternalW 函数。该函数首先会将一些参数和标志转换为内部表示形式(不幸的是，我们无法访问这些内部结构)。

新进程的优先级类由 CreationFlags 参数决定。在 Windows 中，共有六种优先级类：Idle(空闲)、Below Normal(低于正常)、Normal(正常)、Above Normal(高于正常)、High(高)、Real-time(实时)。如果没有指定优先级类，默认使用 Normal。如果请求了 Real-time 但调用者没有相应的特权，则优先级会被降级为 High。

接下来，如果该进程需要被调试，kernel32.dll 会初始化与本地调试接口的连接，并设置默认的严重错误模式(如果指定了的话)。用户指定的属性列表会被转换为其原生格式，并添加任何额外的内部属性。用于进程和初始线程的安全属性也会被转换为内部表示形式。

下一步是打开要运行的可执行镜像文件。这项任务是在 NtCreateUserProcess 系统调用中完成的。首先，函数会再次验证传入的参数，以确保它们未被篡改。然后，它会尝试查找并打开合适的 Windows 镜像，并创建一个节对象(section object)，该对象将在稍后被映射到新进程的地址空间中。

如果该镜像不是一个有效的 Windows 可执行文件，系统会尝试寻找一个支持程序来运行它。例如，如果该可执行文件是一个 MS-DOS 或 Win16 应用程序，系统会使用 ntvdm.exe(适用于 32 位 Windows)来运行它。这确保了旧版 DOS 或 Win16 应用程序可以在 Windows 环境中正确运行。不过，这一功能在现代 Windows 系统中已逐渐被淘汰，因此你需要手动启用它才能使其正常工作。

一旦可执行镜像被成功打开，接下来的阶段就是创建 Windows 执行体进程对象(Executive Process Object)。这一步包括设置进程的虚拟地址空间以及其他关键结构。执行体进程对象 充当了进程中所需所有资源的容器，包括内存、句柄和线程。

在进程对象创建完成后，系统会创建初始线程(Initial Thread)。这一步包括设置线程的堆栈、上下文以及执行体线程对象。该线程负责执行程序的入口点，并管理进程的执行流程。

在初始线程创建完成后，Windows 会执行一些与子系统相关的初始化任务。这些任务对于将新进程集成到 Windows 子系统中至关重要，该子系统为进程提供了正常运行所需的环境和资源。

除非指定了 CREATE\_SUSPENDED 标志(在这种情况下线程会保持挂起状态，直到被显式恢复)，否则初始线程将被启动。启动线程涉及切换到用户模式并执行进程的入口点。

最后，在新进程和线程的上下文中，地址空间会被初始化。这包括加载任何必需的 DLL 文件，并执行其他必要的设置任务。一旦这些步骤完成，进程便开始执行其自身的代码，整个进程的创建过程也就宣告完成。

\mySubsubsection{4.3.1}{是选择 PE，还是放弃 PE？}

“是选择 PE，还是放弃 PE？”\footnote{译者注：这是对莎士比亚名句 “To be or not to be” 的一种戏仿，用在技术语境中时，通常是指 是否使用 PE(Portable Executable，可移植可执行文件)格式 的问题。}与具有特定含义的所有其他文件一样，产生基于 Windows 的可执行文件的字节也具有特殊含义。

Windows 可移植可执行文件(Portable Executable，简称 PE)格式是一种用于可执行文件、目标代码、DLL 以及其他在 Windows 操作系统中使用的系统文件的文件格式。它是 DOS(以及 FreeDOS)、Windows 和 ReactOS 中可执行文件的标准格式，涵盖了可执行文件(EXE)和动态链接库(DLL)等类型。

PE 格式被设计为可扩展的，并能够支持现代操作系统特性。如果你对这一领域感兴趣，网上有许多优秀的学习资源，我们鼓励你深入研究这一主题，因为由于篇幅限制，本书无法涵盖所有相关的详细信息。

以下是对其结构和组件的简化说明，主要聚焦于与本章内容相关的部分：

\begin{itemize}
\item 
DOS 文件头(IMAGE\_DOS\_HEADER)：

文件以 MZ 开头，这是 Mark Zbikowski 的姓名首字母缩写，他是供职于微软期间创建该格式的工程师。接下来是 DOS 文件头，它是 MS-DOS 时代的遗留结构。该文件头中包含一个小型的 DOS 桩程序(stub program)，如果该可执行文件在 DOS 环境下运行，它会显示一条消息：“This program cannot be run in DOS mode”。DOS 文件头的最后部分包含一个指向 PE 文件头位置的指针。

\item 
PE 文件头(IMAGE\_NT\_HEADERS)：

\begin{itemize}
\item 
签名(Signature)：用于标识该文件为 PE 文件。签名是一个 4 字节的值，即 \verb|PE\0\0|。

\item 
文件头(IMAGE\_FILE\_HEADER)：包含有关文件的基本信息，例如目标机器类型、节区数量、文件创建的时间和日期，以及可选文件头的大小。

\item 
可选文件头(IMAGE\_OPTIONAL\_HEADER)：提供程序加载和运行所需的关键信息。尽管名为“可选”，但对于可执行文件来说它是必需的，其中包括以下内容：

\begin{itemize}
\item 
魔数(Magic number)：标识文件格式(例如，PE32 表示 32 位，PE32+ 表示 64 位)

\item 
AddressOfEntryPoint：程序开始执行的地址

\item 
ImageBase：可执行文件在内存中的首选基地址

\item 
SectionAlignment：内存中节区的对齐方式

\item 
SizeOfImage：内存中整个映像的大小

\item 
Subsystem：所需子系统(如 Windows GUI 或 CUI)
\end{itemize}

\end{itemize}

\item 
节区头(IMAGE\_SECTION\_HEADER)：

紧随 PE 文件头的是一个或多个节区头，每个节区头描述了文件中的一个节区。这些节区包含了程序的实际数据和代码。以下是一些常见的节区：

\begin{itemize}
\item 
.text：包含可执行代码。

\item 
.data：包含已初始化的全局变量和静态变量。

\item 
.text：包含可执行代码。

\item 
.bss：包含未初始化的数据。

\item 
.rdata：只读数据(如字符串字面量和常量)。

\item 
.idata：导入表，列出可执行文件所依赖的函数和 DLL。

\item 
.edata：导出表，列出可执行文件暴露给其他模块的函数和数据。
\end{itemize}

\item 
数据目录(Data Directories)：

属于可选文件头的一部分，这些目录提供了关于可执行文件内各种表和数据结构的位置与大小的信息，包括：

\begin{itemize}
\item 
导入表(Import table)：列出可执行文件导入的 DLL 和函数。

\item 
导出表(Export table)：列出可执行文件导出的函数和数据。

\item 
资源表(Resource table)：包含嵌入在应用程序中的资源，如图标、菜单和对话框。这些资源根据其类型存储在一个资源树中，并支持同一资源的多种语言变体。

\item 
异常表(Exception table)：包含异常处理相关信息。

\item 
重定位表(Relocation table)：用于地址修正(address fixups)。
\end{itemize}

\item 
节区(Sections)：

实际的节区紧跟在文件头之后，包含了可执行代码、已初始化数据以及其他程序运行所需的组件。

每个节区都根据可选文件头中指定的 SectionAlignment 值进行对齐。
\end{itemize}

对于我们来说，这一系列节区及其子结构中最重要且最有趣的部分是 AddressOfEntryPoint 字段。

\mySubsubsection{4.3.2}{上手操作}

我们最初的方法将是一个非常干净的应用程序，一个经典的 “Hello World！”

\begin{cpp}
#include <iostream>

int main() {
  std::cout << "Hello World!\n";
}
\end{cpp}

这将帮助我们理解一个非常简单的应用程序在 Windows 下是如何被加载和执行的。不过，在进一步深入之前，有一点小小的说明：在 Windows 中存在多种不同类型的应用程序，这一点由 PE 文件头中的 OptionalHeader/Subsystem 字段指明。

出于我们的目的——剖析一个应用程序的启动过程——我们将创建一个控制台应用程序(Console Application)。虽然还有其他类型的应用程序可供研究，但它们通常更为复杂。例如，如果是一个图形界面(GUI)应用程序，那么我们必须实现复杂的消息循环和依赖项，因此我们选择保持简单。假设我们已经成功编译了这个合成的控制台应用程序，我们可以启动 Ghidra 并查看，文件的很大一部分与之前展示的标准 PE 文件头非常相似：

\myGraphic{0.9}{content/chapter4/images/12.png}{图 4.12 – PE 头的内容}

这是一大段信息需要消化，但对我们来说最感兴趣的是 AddressOfEntryPoint 字段。目前，它指向一个名为 entry 的函数。这就是我们应用程序开始执行的位置，因此让我们更详细地看看这个函数。如果我们进一步深入，查看 entry 到底调用了什么，我们将最终到达以下函数：

\begin{cpp}
ulong __cdecl entry(void *param_1) {
  ulong uVar1;
  uVar1 = __scrt_common_main();
  return uVar1;
}
\end{cpp}

这本身就是一个有趣的发现，因为它看起来像是基于控制台的 Windows 应用程序的入口点。让我们进一步探索这一点。接下来运行的函数如下所示：

\begin{cpp}
int __cdecl __scrt_common_main(void) {
  int iVar1;
  __security_init_cookie();
  iVar1 = __scrt_common_main_seh();
  return iVar1;
}
\end{cpp}

Microsoft的页面\footnote{\url{https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/security-init-cookie?view=msvc-170}}中详细描述了 \verb|__security_init_cookie()| 函数。然而，另一个函数则属于一种完全不同的类型。它执行了大量的初始化工作，例如设置终端环境和处理初始化过程中的错误。在某个阶段，会执行以下代码片段：

\myGraphic{0.9}{content/chapter4/images/13.png}{图 4.13 –  main() 的调用}

你可能已经猜到了，invoke\_main 负责调用 main()：

\begin{cpp}
int __cdecl invoke_main(void) {
  char **_Argv;
  char **_Env;
  undefined4 *puVar1;
  int *piVar2;
  int iVar3;
  _Env = (char **)__get_initial_narrow_environment();
  puVar1 = (undefined4 *)___p___argv();
  _Argv = (char **)*puVar1;
  piVar2 = (int *)___p___argc();
  iVar3 = main(*piVar2,_Argv,_Env);
  return iVar3;
}
\end{cpp}

此时，我们已经到达调用 main() 函数的阶段。即使是像 “Hello World!” 这样一个简单的应用程序，也需要执行大量模板代码(boilerplate code)。现在，是时候更进一步，让我们的人造应用程序在 Ghidra 中进行一次“旅程”了(为了简洁起见，我们省略了创建项目、编译和链接应用程序的过程；姑且假设这个应用程序是通过魔法自己生成的)。

由于我们最感兴趣的是确定 main() 之前函数调用的顺序，并且我们知道 my\_a 和 my\_other\_a 变量是以全局方式初始化的，因此我们需要在二进制文件中进行查找。在某个时刻，我们会发现以下有趣的数据：

\myGraphic{0.9}{content/chapter4/images/14.png}{图 4.14 –  根据 Ghidra 显示的 .CRT\$XCU 节区}

嗯，这看起来很有趣，尤其是那个神秘的 \verb|.CRT$XCU| 文本。这让我们回想起前几段中讨论 PE 文件节区时的内容：可执行文件中的每个节区都是一个独立的区域，用于存放不同类型的数据或代码。

每个节区都有特定的用途，并具有定义其行为以及操作系统应如何处理它的属性。微软官网上有一份非常出色的文档\footnote{\url{https://learn.microsoft.com/en-us/cpp/c-runtime-library/crt-initialization?view=msvc-170}}，讨论了负责初始化 C 运行时(CRT)的各个节区，下面是对该文档的一个简要总结：

根据文档说明，默认情况下，C 运行时库是通过链接器自动包含的，这确保了 CRT 被正确初始化、全局构造函数被调用，最终执行用户定义的 main() 函数。当编译器遇到全局构造函数时，它会创建一个动态初始化器，并将其放置在 \verb|.CRT$XCU| 节区中。

CRT 使用了一些特定的指针，比如 \verb|.CRT$XCA| 和 \verb|.CRT$XCZ| 节区中的 \verb|__xc_a| 和 \verb|__xc_z|，来定义初始化器列表的起始和结束位置，从而确保它们按照正确的顺序被调用。我们之前讨论过的 \verb|__scrt_common_main_seh()| 函数就负责正确设置这些内容。

这些符号名称是由 CRT 预定义的，而链接器则按字母顺序排列这些节区。这种排序机制确保了 \verb|.CRT$XCU| 中用户定义的初始化器会在标准节区之间被执行。

为了控制初始化顺序，开发者可以使用特定的 \#pragma 指令，将他们的初始化器放入未使用的保留节区中，例如：

\begin{itemize}
\item 
\verb|.CRT$XCT|(在编译器生成的初始化器之前执行)

\item 
\verb|.CRT$XCV|(在编译器生成的初始化器之后执行)
\end{itemize}

这一技术详见于前几段提到的 CRT 启动文档中。但在你急于使用这项技术之前，请先阅读下文，因为事情比看起来要复杂一些。

根据微软的说法，这个主题过于依赖平台和编译器的具体实现，因此我们不打算深入探讨这些领域，尤其是考虑到官方文档中给出的如下警告：

\begin{shell}
CRT$XCT和.CRT$XCV 这些名称目前并未被编译器或 CRT 库使用，但无法保证它们将来也不会被使用。此外，你的变量仍可能被编译器优化掉。在采用这种技术之前，请务必考虑潜在的工程实现、维护和可移植性问题。
\end{shell}

所以，我们再次重申一下官方警告的内容：除非你真的必须这么做，否则请避免使用这些文档描述不清、半遮半掩的“语言和编译器特性”，因为正如官方警告所说——今天能用的东西，明天可能就失效了，甚至可能在下一次系统更新之后就无法正常工作。

相反，让我们把注意力转向我们在 \verb|.CRT$XCU| 节区中“发现”的那些函数，看看这个明显非标准 C(也不是 C++)的命名背后究竟隐藏着什么样的魔法：

\begin{cpp}
void __cdecl dynamic_initializer_for_my_a(void)
{
  int iVar1;
  uchar *unaff_EDI;
  undefined4 *puVar2;
  puVar2 = (undefined4 *)&stack0xfffffffc;
  for (iVar1 = 0; iVar1 != 0; iVar1 = iVar1 + -1) {
  *puVar2 = 0xcccccccc;
  puVar2 = puVar2 + 1;
}

__CheckForDebuggerJustMyCode(unaff_EDI);
  A::A(&my_a,my_string);
  atexit(dynamic_atexit_destructor_for_my_a);
  return;
}
\end{cpp}

在执行了一些维护任务(例如使用 0xcccccccc 值初始化栈内存)之后，我们可以看到对类 A 构造函数的调用，其中第一个参数是典型的 this 对象，并且再次为该对象注册了一个 atexit 函数用于调用类的析构函数。

这个 0xcccccccc 模式是 Visual C++ 编译器用来标记未初始化栈内存的典型方式，便于在调试过程中更容易发现使用未初始化内存的问题。有趣的是，这里的循环似乎没有被执行。然而，如果我们深入研究那些包含较大 C 风格数组的函数在调试构建中的表现，我们会看到这种栈保护机制的实际应用，以及设置良好的栈金丝雀(stack canaries)。

栈金丝雀是一种安全机制，旨在检测并防止基于栈的缓冲区溢出攻击。它通过在函数的局部变量和控制数据(如返回地址和保存的帧指针)之间放置一个特殊值(称为“金丝雀”)来实现。

如果发生缓冲区溢出，金丝雀的值会被修改，从而表明发生了异常行为。这使得程序可以采取纠正措施，例如终止执行以防止被利用。

这个术语的来源有些模糊，但它可以追溯到煤矿中使用金丝雀的历史用途。矿工会把金丝雀带入矿井中以检测一氧化碳等有毒气体。由于金丝雀比人类对这些气体更敏感，如果鸟生病或死亡(即停止唱歌)，就表示矿工需要立即撤离。虽然这并不属于神话级别，但非常实用——特别是如果你是矿工而不是那只金丝雀的话。

有了这些概念的基础后，我们现在大致了解了应用程序在 Windows 下是如何加载的，尽管目前仅限于控制台环境。但别忘了，Windows 本质上是一个图形用户界面(GUI)环境。它创建窗口和对话框，拥有消息循环，并处理大量事件。

不过，Windows GUI 应用程序的启动过程与控制台应用程序并没有太大不同。主要区别在于：invoke\_main 函数在调用特定于 GUI 的 WinMain 函数之前会调用两个不同的函数，分别用于处理窗口的显示状态和命令行参数。

\begin{itemize}
\item 
第一个函数允许我们以不同方式显示应用程序的窗口。

\item 
第二个函数则是以宽字符串格式表示的应用程序命令行参数。
\end{itemize}

其余部分就是调用 WinMain，从此我们就进入了熟悉的领域，至少对于有这方面经验的开发者来说是如此。

在本章结束之际，我们唯一要做的就是鼓励读者在逆向工程和修改二进制文件时勇于实验——这是真正理解某个特定功能在我们的系统上如何表现的唯一途径。





