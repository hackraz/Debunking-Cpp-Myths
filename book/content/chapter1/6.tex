
从书本或结构化课程中学习只是一种方法;另一个是通过个人探索。想象一下学习 C++,但必先浏览一堆代码示例,而是按照你认为应该工作的方式编写代码,并逐步学习你的直和实际语言之间的差异。事实上,即使在参加结构化学习课程时,人们也会自然而然地这两种方法结合起来。

通过探索学习的一个缺点是很难理解你的进度,而且你经常会陷入困境。一种方法可以提帮助:TDD。

TDD 是一种违反直觉的有效增量设计方法。其最简单的描述如下:

\begin{itemize}
\item 
第 1 步，也称为红色：编写一个失败的测试，并显示需要实现的下一个情况

\item 
第 2 步，也称为绿色：编写最简单的代码以使测试通过 （并保持所有其他测试通过）

\item 
第 3 步，也称为重构：重构生产代码和测试代码以简化。
\end{itemize}

这个红-绿-重构循环以非常小的周期(通常为 5-10 分钟)重复,直到与当前功能或用户情关联的所有行为都已实现。

\begin{myTip}{对测试驱动开发（TDD）的误解进行澄清}
就我个人而言，我是测试驱动开发（TDD）的忠实支持者，并在过去十多年中成功地使用它进行开发。事实上，本书中的示例代码就是我通过 TDD 方法编写完成的。然而，我也知道，TDD 在业界的接受程度褒贬不一。一部分原因是人们想象力的局限，一个常见的问题是：“我怎么能为一个还不存在的方法写测试？”其实这和你编写尚未存在过的代码是一样的道理：你设想它已经存在，并专注于期望的输入和输出。其他批评则源于对 TDD 究竟是什么以及它是如何工作的误解。一些所谓的“TDD 失败”案例，常常一开始就把注意力放在边界情况上，结果很快让事情变得复杂起来——而实际上你应该从正常路径（happy path）开始。有人声称 TDD 会拖慢开发进度，这种说法有一定道理，但事实是这种方法让我们在编码时更加全面和有条理，从而避免了通常在后期才发现、修复起来既费力又压力巨大的问题。最后需要说明的是，TDD 并不是用来设计高性能算法的方法，但它可以帮助你先找到一个可行的解决方案，之后你可以借助测试套件对其进行优化。
\end{myTip}

要了解如何学习具有修改后的 TDD 周期的编程语言,我们需要澄清有关 TDD 的两件事。
首先,TDD 是违反直觉的,因为它需要长时间关注问题域,而大多数编程课程教我们如何理解决方案域。 其次,TDD 是一种增量设计方法;也就是说,找到一个代码结构,以逐步方式解决特定问题,而不是一次全部解决。这两个特性使 TDD 最适合学习新的编程语言并提供一些支持。

想象一下,在能够运行程序之前,你不是学习 C++ 的全部知识,而是学习如何编写测试。这很容易,因为测试往往使用语言的一小部分。 此外,运行测试会为您提供即时反馈:失或红色表示出现问题,成功或绿色表示一切正常。最后,这允许您在有一个或多个测试探索问题,并弄清楚如何编写代码以使编译器能够理解它 - 这就是您在学习语言时想要的弄清楚错误消息可能有点问题,尤其是在 C++ 中,但是如果你有一个人(或者将来的 AI 寻求帮助,你会在路上学到很多东西,并在你学到新东西时看到绿色条。

这种方法已经进行了小规模的测试,效果非常好。以下是 C++ 的学习会话的工作原理。

\mySubsubsection{1.6.1}{设置}

至少有两个参与者参与了学习过程;我们称他们为教练和学生。我更喜欢使用教练而不是讲,因为目标是引导学生走上自己的学习路径,而不是直接教他们。

我将讨论会议的其余部分,就好像只涉及一名学生一样。类似的设置也适用于多个学生。

演员需要做的第一件事是设定一个目标。通常,目标是至少学习 C++,但也可以是更多地解特定主题 – 例如,std::vector 或 STL 算法。

在技术设置方面,此过程最适合两个人在同一显示器上查看代码并并肩工作。虽然这最好自完成,但也可以通过各种工具进行远程作。

首先,Coach 需要设置一个由测试库、生产代码文件和测试文件组成的简单项目。需要提供种运行测试的简单方法,可以是按钮单击、键盘快捷键或简单命令。我为 C++ 推荐的设是使用 doctest (\url{https://github.com/doctest/doctest}),这是一个仅头文件测试库,它非常,并且支持生产所需的许多功能。

以下是此项目最简单的结构:

\begin{itemize}
\item 
测试文件 test.cpp

\item 
生产头文件 prod.h

\item 
doctest.h 文件

\item 
允许我们运行测试的 Makefile
\end{itemize}

根据学习目标,可能还需要production.cpp 文件。

Coach 还需要提供第一个失败测试的示例,并演示如何运行测试。 学生接管键盘并运行测。此测试可以非常简单,如以下示例所示:

\begin{cpp}
#define DOCTEST_CONFIG_IMPLEMENT_WITH_MAIN
#include "doctest.h"
#include "prod.h"

TEST_CASE("Test Example"){
  auto anAnswer = answer();

  CHECK(anAnswer);
}
\end{cpp}

prod.h的内容如下所示：

\begin{cpp}
bool answer(){
  return true;
}
\end{cpp}

然后,首要任务是使测试通过。教练会不断问学生的问题是:“你认为这将如何运作?写何你觉得直观的东西。如果学生找到正确答案,那就太好了!如果没有,请出示正确答并说明原因。

这个例子非常有用,因为它引入了语言的一些元素并展示了它们的工作原理:函数声明、 量、测试和返回值。同时,这个过程非常好,因为它给了学生一个进步的衡量标准:测通过是好的,而测试不通过意味着有东西要学。

完成所有这些后,是时候进入探索阶段了。

\mySubsubsection{1.6.2}{探索语言}

以这种方式探索编程语言有两种方法:通过逐个介绍概念的简单问题,也称为 koans,或者过解决更复杂的问题。

无论哪种方式,方法都保持不变:首先,教练编写一个简单的测试,或者帮助学生编写一失败的简单测试。然后,要求学生编写他们认为最直观的解决方案。测试运行,如果测没有通过,教练需要解释什么不起作用。教练或学生做出改变,当测试通过时,步骤以显的进步结束。

在此过程中,专注于学生的下一个自然步骤非常重要。如果学生有具体的问题或好奇心, 一次测试可以处理这些问题或好奇心,而不是通过脚本化的过程。这种适应性学习方式助于学生感到掌控,这个过程给了他们一种自主的错觉,最终变成了现实。

\mySubsubsection{1.6.3}{内存问题呢?}

在本章中,我们花了一些时间讨论这样一个事实,即 C++ 程序员需要比使用其他主流编程言的同事更多地了解内存管理。他们如何用这种方法学习内存管理?测试不会捕获内存题,对吗? 

事实上,我们希望学生了解到他们需要从一开始就关心内存。 

因此,需要将内存检查集成我们的测试套件中。我们有两种选择:使用专用工具或选择可以检测内存问题的测试库 像algrind 这样的专业工具很容易集成到我们的流程中。请参阅以下 Makefile 示例:

\begin{shell}
check-leaks: test
  valgrind -q --leak-check=full ./out/tests

test: test.cpp
  ./out/tests

test.cpp: .FORCE
  mkdir -p out/
  g++ -std=c++20 -I"src/" "test.cpp" -o out/tests

.FORCE:
\end{shell}

test.cpp 目标是编译测试。测试目标依赖于 test.cpp 并运行测试。第一个目标 check-leaks 会动运行 valgrind,并可选择仅在错误出现时显示错误,这样学生就不会不知所措。在没有何参数的情况下运行 make 时,将选择第一个目标,因此默认情况下会进行内存分析。

假设我们在运行存在内存泄漏的测试,如以下示例所示:

\begin{cpp}
bool answer(){
  int* a = new int(4);
  return true;
}
\end{cpp}

我们立即收到了以下输出：

\begin{shell}
==========================================================[doctest]
test cases: 1 | 1 passed | 0 failed | 0 skipped
[doctest] assertions: 1 | 1 passed | 0 failed |
[doctest] Status: SUCCESS!
valgrind -q --leak-check=full ./out/tests
[doctest] doctest version is "2.4.11"
[doctest] run with "--help" for options
==========================================================[doctest]
test cases: 1 | 1 passed | 0 failed | 0 skipped
[doctest] assertions: 1 | 1 passed | 0 failed |
[doctest] Status: SUCCESS!
==48400== 4 bytes in 1 blocks are definitely lost in loss record 1 of 1
==48400== at 0x4849013: operator new(unsigned long) ==48400== by 0x124DC9: answer()
\end{shell}

此输出为与学生的对话提供了足够的信息。

第二个选项是使用已经实施了内存泄漏检测的测试库。 CppUTest （\url{http://cpputest.github.io/}） 就是这样一个库，它还具有支持 C 和适用于嵌入式代码的优势。

有了这些工具，现在很明显，这种方法可以向任何想要尝试或深入研究特定部分的人传授 C++，使用探索作为一种方法。

现在我们今天学习了两种学习 C++ 的方法，让我们回过头来了解什么是 C++ 的利基，以及为什么它必须比其他语言更复杂。














