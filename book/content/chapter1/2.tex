C++ 的早期版本被视为 C 语言的一种扩展，仅仅引入了一种新的编程范式——面向对象编程（OOP），从而承诺解决日益增长的代码库所带来的诸多问题。这个初始版本的 C++ 是相当严苛的：作为程序员，你必须深入理解内存分配与释放机制、指针运算的工作方式，并且要时刻警惕无数细微之处——这些地方你很容易忽略，而它们通常会导致令人困惑的错误信息。

当时程序员圈流行的文化氛围也无助于学习这门语言：一个“真正的”程序员被认为必须精通 CPU、内存、各种汇编语言、操作系统原理以及编译器的所有细节。此外，标准化委员会在几十年的时间里几乎没有采取任何措施来减少此类错误的可能性。难怪这门语言的名声在近 40 年后依然如影随形。我自己的学习经历也印证了当年掌握它有多么困难。

我在 90 年代读专科时第一次接触到 C++，那时的学习经历让我既感到好奇又充满困惑。我意识到了这门语言的强大之处，但感觉它似乎总是在和我作对——至少我当时是这么认为的。我必须努力写出能正常运行的代码。那时我还不太熟悉 STL，因为它尚未成为标准中广为人知的一部分，所以我最初的许多 C++ 程序都涉及指针的使用。

在当时的 C++ 考试中，一个常见的问题是区分“指针数组”和“数组指针”。我只能想象这门语言的复杂性在出题方面是多么“有用”！顺便提一下，下面展示了“指针指向数组”和“数组包含指针”之间的区别，这是 C++ 考试中的一个常见问题：

\begin{cpp}
int(*pointerToArrayOf10Numbers)[10];

int *arrayOfTenPointers[10]
\end{cpp}

我继续通过实践和当时能找到的书籍学习 C++，那时互联网尚未普及，知识并不像今天这样触手可及。然而，我对这门语言真正深入的理解，来自于我在 2000 年左右参与的一个项目。

这个项目的负责人是一位非常技术化的比利时人，他为我们设定了非常明确的编码规范和开发流程，我们必须遵循这些流程才能写出尽可能高质量的 C++ 代码。这种对卓越的追求并不仅仅出于他的个人偏好，而是源自项目本身的需求：我们在开发一个在多年之后才被正式称为“NoSQL”的数据库引擎。

为了完成这个项目，我必须深入学习两本 C++ 经典著作中的所有规则：Scott Meyers 所著的《Effective C++》和《More Effective C++》。这两本书一共总结了 90 条面向 C++ 程序员的编程指南，涵盖了资源初始化与释放、性能优化技巧、继承、异常处理等方方面面。也正是从这个时候起，我开始广泛使用 STL，尽管当时的标准库远不如今天这般丰富。

这些新掌握的知识让我的 C++ 程序更加可靠，也让我变得更为高效。而另一个重要的推动因素是我们在实践中结合这两本书的智慧所采用的开发流程：我们编写单元测试，进行设计和代码审查，并且谨慎地编写每一行代码，因为我们知道每一行都将在提交到代码库之前被同事仔细检视。这种流程使我们的代码几乎无 bug，并帮助我们在合理的时间内实现了高性能的复杂功能。

然而，语言本身依然在与我们“作对”。我们知道如何写出好的 C++ 代码，但这需要极高的专注和细致入微的关注力，不可避免地拖慢了我们的开发速度。仅仅掌握 C++ 是不够的；语言本身也需要回馈开发者一些东西。

完成这个项目后，我暂时离开了 C++ 的世界，转而学习了 C\# 和托管 C++、Java、PHP、Python、Haskell、JavaScript 和 Groovy——当然，仅限于那些我用于专业开发的语言。虽然每一种语言相比 C++ 都提供了更高的抽象层次，也带来了更少的烦恼，但我仍然怀念自己编程成长时期的那段经历。了解 C++ 及其复杂的内存管理机制，让我对其他语言的底层运行机制有了深刻理解，使我能够充分发挥它们的潜力。例如，Haskell 对我来说就格外亲切，因为它与我从 Andrei Alexandrescu 所著的经典著作《Modern C++ Design》中学到的元编程技术非常相似。C++ 一直活在我的脑海中，不仅是我的第一门职业编程语言，也成为我此后所学所有语言的基础。

令我欣喜的是，大约在 2010 年，传来了好消息：C++ 标准化委员会终于开始频繁地对语言进行更新。此前多年，最新的 C++ 标准一直是 C++98；而现在，我们每隔三年就能看到一个新的版本发布。这种持续的标准更新引入了函数式编程范式、ranges（范围）、新的并行与异步编程原语，以及移动语义等特性。但对于如今想学习 C++ 的人来说，最大的变化在于内存管理的简化和 auto 类型的引入。这些改进带来的最大突破是，即使是 Java 或 C\# 程序员也能轻松理解现代 C++ 程序——而在 Java 和 C\# 刚刚出现时，这一点还远远不能确定。

这意味着今天的 C++ 比 90 年代要容易得多。一个典型的例子就是曾经常见的考试问题：“指针数组和数组指针之间的区别”已经完全失去了意义。裸数组可以轻松地用 std::vector<> 或 std::list<> 替代，而指针则可以用更安全的 std::shared\_ptr<> 或 std::unique\_ptr<> 取代。这大大减少了手动管理指针内存分配和释放所带来的担忧，既美化了代码结构，又降低了产生那些令人费解的错误信息的可能性——这些错误曾是 C++98 的标志。

然而，我们也不能说现在的 C++ 已经和其他主流语言一样易于学习。让我们来看看原因。
























