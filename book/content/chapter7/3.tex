我深信，软件开发的核心挑战在于将系统的静态视图（代码）在脑海中转化为其动态行为——即程序运行时的实际表现。程序员每次考虑修改时都需要在脑中"运行"代码，这种思维活动虽可自动完成，却始终消耗着大量心智资源。这也正是我认为测试驱动开发(TDD)和渐进式设计有价值的原因：它们能将这部分心智消耗转移到反复运行测试的过程中。

这个根本性问题在单线程环境下已属不易，对于并行或并发设计更是难上加难。我们不仅需要预判代码行为，还要设想其与同时运行的其他代码如何交互。因此，理解并行执行所需的想象力和脑力消耗是首要挑战。

其次是纯粹的技术挑战：

\begin{itemize}
\item 
资源共享时管理难度陡增，尤其是多线程可能修改同一数值。某线程可能正在使用已被其他线程改变的值，导致错误结果。内存地址可能被某线程释放，而另一线程却试图读写。

\item 
基础设施共享同样棘手。某个线程可能因bug独占资源，长时间阻塞其他线程。虽然多核任务分离能缓解此问题，但任务最终需要汇聚，仍会导致性能下降。线程可能无限等待或直到超时。
\end{itemize}

从零实现并行/并发程序堪称程序员面临的最艰巨任务之一。我曾花费整整一周调试线程同步问题，期间明显感受到技术主管和项目经理开始怀疑我的能力——尽管我对自己仍有信心，但耗时之长确实令人沮丧。

正因如此，涌现出许多辅助实现并发/并行程序的库和模式。它们大多要求我们将代表线程的函数传递给特定方法，由后者处理线程同步的复杂性。这种方案通过任务类型分离实现了可行性。此外，受函数式编程启发的架构模式（如Hadoop实现的MapReduce）帮助我们应对大规模并行化挑战。

由此可见，讨论现代并行编程方法就必然涉及函数式编程的解决思路。
