如你所见，编写并行和并发代码并非"随心所欲地编写，然后交给工具和编译器处理"这么简单。或许未来借助人工智能的介入能实现这一点，但根据我目前使用编程助手的经验来看，这似乎还很遥远。

实际上，你必须根据选择的编程模型来结构化代码。如果一开始就将代码库写成单线程应用且不使用函数式结构，后续改造将会非常困难。我观察到对象与actor之间存在某种对应关系——理论上或许可以将每个对象转化为actor，每个方法转化为事件，但这种想法过于理想化。现实情况是，当我们将同步系统改为基于事件的系统时，仍可能面临大量问题，其中许多问题不仅难以调试，还需要深入理解actor模型及其实现框架。

最佳实践是：在你选择的范式内重新设计应用——要么采用以数据为中心的函数式范式，要么选择以行为为核心的actor模型。

在以数据为中心的范式下，开发者需要关注输入数据及达成预期输出所需的转换过程。每个转换步骤都遵循不可变原则——接收数据输入并返回新的数据结构输出。正如我们所见，这类转换天然具备可并行化特性。

有时我们需要自定义算法或优化现有实现，此时仍可遵循相同模式编写专属实现。通过执行策略进行微调，最终能构建出高度可定制且易于优化的系统。

而以行为为核心的范式则将对象视为接收消息的actor，这更接近Alan Kay对面向对象编程的原始构想（其核心思想可参考\url{https://www.purl.org/stefan_ram/pub/doc_kay_oop_en}的邮件论述）。这种不强调类而聚焦消息传递的范式，在Smalltalk语言中得到了最纯粹的体现。开发者需要基于actor及其消息机制从头构建应用，并验证输出是否符合预期。这要求深入理解各类actor和消息传递机制，才能选择适合问题场景的方案。如示例所示，actor并不保证执行顺序——这可能成为系统设计需要考虑的因素。

由此构建的系统具备高度可扩展性，但理解和调试难度也相应增加。这意味着我们无法自动将同步单线程应用直接转换为并行/并发系统，大多数情况下都需要进行架构重构。