本章已经揭示，在 C++ 中，默认情况下编写不安全的代码实在是过于容易。尽管后续标准引入了诸多改进，如 STL 容器和智能指针等，开发者仍然有可能犯下代价高昂的错误。虽然可以通过自动化测试、探索性测试以及渗透测试等手段来捕获这些问题，但编程语言本身的默认行为才是问题的根本所在。遗憾的是，C++ 的默认设定依然偏向于不安全。

经过上述分析，可以得出一个明确的结论：C++ 本质上仍然是一个内存不安全的语言。要编写出内存安全的代码，开发者必须持续保持高度警惕，并且依赖工具链的支持。即将纳入标准的安全规范或许能够缓解大部分问题，但是世界上仍有大量的 C++ 代码遵循着2000年代的原始写法，这些遗留代码构成了巨大的挑战。

现状可以说是喜忧参半：一方面，现代 C++ 提供了许多增强功能来帮助开发者编写更安全的代码；另一方面，由于历史遗留和技术惯性，完全转向安全编码实践的道路依旧漫长而艰巨。

在下一章中，将审视 C++ 中并行与并发的实现现状，探讨如何在确保程序性能的同时，避免常见的同步问题和其他并发陷阱。这将引导我们进一步理解 C++ 在处理复杂应用时的能力与局限。