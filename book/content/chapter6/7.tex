本章已经揭示，在C++中默认编写不安全的代码实在过于容易。尽管后续标准、STL容器和智能指针带来了诸多改进，开发者仍可能犯下代价高昂的错误。当然，我们可以通过开发者自动化测试、探索性测试、渗透测试等手段捕获这些问题——但编程语言的默认行为才是根本，而C++的默认设定依然不安全。

经过这些分析，我们只能得出一个结论：C++本质上仍是内存不安全的语言，要编写内存安全的代码必须持续保持警惕并借助工具链支持。即将纳入标准的安全规范(safety profiles)或许能缓解大部分问题，但世界上仍有不可估量的C++代码保持着2000年代的原始写法。现状可谓喜忧参半。

下一章我们将审视C++中并行与并发的实现现状。