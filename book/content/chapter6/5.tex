
假设我们仅使用STL容器、避免裸指针，必要时采用标准库的智能指针，并始终以内存安全为准则设计类型——这样就能高枕无忧了吗？
C++标准委员会知名成员Herb Sutter在其2024年3月11日发表的博客《C++安全性的现状与思考》(\url{https://herbsutter.com/2024/03/11/safety-in-context/}) 中深入探讨了这一问题。他的结论是：默认情况下，C++代码仍太容易产生安全隐患。文章指出需要重点关注的四大领域：类型系统、边界检查、初始化和生命周期管理。虽然C++20已引入部分解决方案（如std::span、string\_view、概念约束和范围感知机制），但语言仍缺乏默认启用、必要时可手动关闭的安全规则。

让我们结合实例解析这些观点。
首当其冲的是C++20引入的std::span——它表示从原生数组、std::array、带尺寸的指针、std::vector或std::string中提取的连续对象序列。其核心优势在于自动推导序列长度，从而根治常见的"差一错误"。现在我们既能安全地向函数传递集合的子集而不必担心序列长度出错，又能彻底禁用指针算术运算，转而使用std::span作为更安全的替代方案。

其次是 string\_view。std::string\_view 提供了一种对字符串的只读视图，从而消除了另一类潜在的安全隐患——比如字符串在不应被修改的地方被意外改动，或是某些原本不安全的字符串操作。

第三是概念（concepts）。概念允许 C++ 程序员对泛型函数和类施加约束，从而增强类型安全性。例如，可以要求传递给泛型函数的值类型必须同时具备加法和减法运算。虽然概念仍在持续改进（C++26 会有更多优化），但它们已经能帮助规避许多潜在的安全问题。

第四是边界感知的范围（bound-aware ranges）。范围库（ranges）让 C++ 程序员可以编写高效、函数式风格的操作来处理集合，从而减少误用风险。范围本身知道自己的边界，开发者不再需要手动传递 begin 和 end 迭代器。

这些改进（如果正确使用）已经让 C++ 比 C++98 时代安全得多。但仍有不足。还记得之前那个访问未预留内存的 std::vector 索引，最终导致运行时内存错误的代码吗？让我们再看一下：

\begin{cpp}
int doSomeWork(int value1, int value2, int value3, int value4) {
  vector<int> values;
  values[0] = value1;
  values[1] = value2;
  values[3] = value3;
  values[4] = value4;
  return values[0] + values[1] + values[3] + values[4];
}
\end{cpp}

这段代码的问题在于，我们可以毫无阻碍地访问超出 vector 已分配大小的索引，同时跳过对索引 2 的初始化。针对此问题，一个可行的解决方案是：

\begin{itemize}
\item 
启用安全模式编译器标志

\item 
编译器在每次索引访问时自动生成范围检查，确保 \verb|0 <= index < collection.size()|

\item 
运行时不会出错，因为尝试越界访问时会被安全机制拦截
\end{itemize}

这样的编译选项可以直接应用于现有代码而无需修改，并能预防未知问题。当然，部分开发者可能会因潜在的性能损耗反对该机制——这正是此类选项应通过编译器标志显式启用（或更理想的方式：默认启用，允许通过标志显式关闭）的原因。

由此可见，要使 C++ 真正实现内存安全，仍有改进空间。